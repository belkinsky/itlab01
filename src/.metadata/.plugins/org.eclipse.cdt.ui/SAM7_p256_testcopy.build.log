
**** Build of configuration Debug for project SAM7_p256_testcopy ****

make all 

-------- begin (mode: ROM_RUN) --------
arm-none-eabi-gcc (GCC) 4.5.1
Copyright (C) 2010 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


Assembling (ARM-only): Compil/srcWinARM/Cstartup.S
arm-none-eabi-gcc -c -mcpu=arm7tdmi  -I. -x assembler-with-cpp -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__ -Wa,-adhlns=Compil/srcWinARM/Cstartup.lst,--gdwarf-2 Compil/srcWinARM/Cstartup.S -o Compil/srcWinARM/Cstartup.o
ROM_MODE enabled
remapping enabled
Vectors at start of RAM
Vectors in section .vectmapped -> .data
RCR setting for remapping enabled
IRQ_Handler_Entry in section .fastrun -> .data

Assembling (ARM-only): Compil/srcWinARM/swi_handler.S
arm-none-eabi-gcc -c -mcpu=arm7tdmi  -I. -x assembler-with-cpp -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__ -Wa,-adhlns=Compil/srcWinARM/swi_handler.lst,--gdwarf-2 Compil/srcWinARM/swi_handler.S -o Compil/srcWinARM/swi_handler.o
SWI-Handler in section .fastrun -> .data

Compiling C: Compil/srcWinARM/Cstartup_SAM7.c
arm-none-eabi-gcc -c  -mcpu=arm7tdmi  -I. -gdwarf-2 -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__  -O0 -ffunction-sections -fdata-sections -Wall -Wcast-align -Wimplicit  -Wpointer-arith -Wswitch -Wredundant-decls -Wreturn-type -Wshadow -Wunused -Wa,-adhlns=Compil/srcWinARM/Cstartup_SAM7.lst  -Iinclude -ICompil/srcWinARM -MD -MP -MF .dep/Cstartup_SAM7.o.d -Wnested-externs  -std=gnu99 Compil/srcWinARM/Cstartup_SAM7.c -o Compil/srcWinARM/Cstartup_SAM7.o 

Compiling C: swi_handler_user.c
arm-none-eabi-gcc -c  -mcpu=arm7tdmi  -I. -gdwarf-2 -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__  -O0 -ffunction-sections -fdata-sections -Wall -Wcast-align -Wimplicit  -Wpointer-arith -Wswitch -Wredundant-decls -Wreturn-type -Wshadow -Wunused -Wa,-adhlns=swi_handler_user.lst  -Iinclude -ICompil/srcWinARM -MD -MP -MF .dep/swi_handler_user.o.d -Wnested-externs  -std=gnu99 swi_handler_user.c -o swi_handler_user.o 

Compiling C: main.c
arm-none-eabi-gcc -c  -mcpu=arm7tdmi  -I. -gdwarf-2 -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__  -O0 -ffunction-sections -fdata-sections -Wall -Wcast-align -Wimplicit  -Wpointer-arith -Wswitch -Wredundant-decls -Wreturn-type -Wshadow -Wunused -Wa,-adhlns=main.lst  -Iinclude -ICompil/srcWinARM -MD -MP -MF .dep/main.o.d -Wnested-externs  -std=gnu99 main.c -o main.o 

Compiling C: cdc_enumerate.c
arm-none-eabi-gcc -c  -mcpu=arm7tdmi  -I. -gdwarf-2 -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__  -O0 -ffunction-sections -fdata-sections -Wall -Wcast-align -Wimplicit  -Wpointer-arith -Wswitch -Wredundant-decls -Wreturn-type -Wshadow -Wunused -Wa,-adhlns=cdc_enumerate.lst  -Iinclude -ICompil/srcWinARM -MD -MP -MF .dep/cdc_enumerate.o.d -Wnested-externs  -std=gnu99 cdc_enumerate.c -o cdc_enumerate.o 

Compiling C: interrupt_Usart.c
arm-none-eabi-gcc -c  -mcpu=arm7tdmi  -I. -gdwarf-2 -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__  -O0 -ffunction-sections -fdata-sections -Wall -Wcast-align -Wimplicit  -Wpointer-arith -Wswitch -Wredundant-decls -Wreturn-type -Wshadow -Wunused -Wa,-adhlns=interrupt_Usart.lst  -Iinclude -ICompil/srcWinARM -MD -MP -MF .dep/interrupt_Usart.o.d -Wnested-externs  -std=gnu99 interrupt_Usart.c -o interrupt_Usart.o 

Linking: main.elf
arm-none-eabi-gcc  -mcpu=arm7tdmi  -I. -gdwarf-2 -DROM_RUN -DVECTORS_IN_RAM -D__WinARM__ -D__WINARMSUBMDL_AT91SAM7S256__  -O0 -ffunction-sections -fdata-sections -Wall -Wcast-align -Wimplicit  -Wpointer-arith -Wswitch -Wredundant-decls -Wreturn-type -Wshadow -Wunused -Wa,-adhlns=Compil/srcWinARM/Cstartup.lst  -Iinclude -ICompil/srcWinARM -MD -MP -MF .dep/main.elf.d Compil/srcWinARM/Cstartup.o Compil/srcWinARM/swi_handler.o   Compil/srcWinARM/Cstartup_SAM7.o swi_handler_user.o main.o cdc_enumerate.o interrupt_Usart.o     --output main.elf -nostartfiles -Wl,-Map=main.map,--cref,--gc-sections -lc  -lm -lc -lgcc   -LCompil/srcWinARM  -TCompil/srcWinARM/AT91SAM7S256-ROM.ld

Creating load file for Flash: main.bin
arm-none-eabi-objcopy -O binary main.elf main.bin

Creating Extended Listing: main.lss
arm-none-eabi-objdump -h -S -C main.elf

main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f14  00100000  00100000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001d0  00200000  00101f14  00010000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  2 .bss          000000e8  002001d0  001020e4  000101d0  2**2
                  ALLOC
  3 .ARM.attributes 0000002c  00000000  00000000  000101d0  2**0
                  CONTENTS, READONLY
  4 .comment      00000011  00000000  00000000  000101fc  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000260  00000000  00000000  00010210  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  00010470  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000273b  00000000  00000000  000105ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000638  00000000  00000000  00012d3a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000a39  00000000  00000000  00013372  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000055c  00000000  00000000  00013dac  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b4a  00000000  00000000  00014308  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000764  00000000  00000000  00014e52  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001a8  00000000  00000000  000155b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_pubtypes 000002a4  00000000  00000000  00015760  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00100000 <_startup>:
_startup:
reset: 

.if (VECTREMAPPED)
/* mthomas: Dummy used during startup */
				LDR PC,=Reset_Addr_F
  100000:	e59ff0f4 	ldr	pc, [pc, #244]	; 1000fc <exit+0x4>
				NOP
  100004:	e1a00000 	nop			; (mov r0, r0)
				NOP
  100008:	e1a00000 	nop			; (mov r0, r0)
				NOP
  10000c:	e1a00000 	nop			; (mov r0, r0)
				NOP
  100010:	e1a00000 	nop			; (mov r0, r0)
				NOP /*.word 0xdeadbeef*/ /* NOP */  /* Reserved Address */
  100014:	e1a00000 	nop			; (mov r0, r0)
				NOP
  100018:	e1a00000 	nop			; (mov r0, r0)
				NOP
  10001c:	e1a00000 	nop			; (mov r0, r0)

00100020 <Reset_Addr_F>:
  100020:	00100028 	.word	0x00100028

00100024 <.RAM_TOP>:
  100024:	00210000 	.word	0x00210000

00100028 <InitReset>:
		.equ    MC_BASE,0xFFFFFF00  /* MC Base Address */
		.equ    MC_RCR, 0x00        /* MC_RCR Offset */
		

		/* store first word in RAM into r4 */
		ldr r0,=__FIRST_IN_RAM
  100028:	e59f00d0 	ldr	r0, [pc, #208]	; 100100 <exit+0x8>
		ldr r4,[r0]
  10002c:	e5904000 	ldr	r4, [r0]
		/* load value at address 0 into R2 */
		ldr r1,=0x00000000
  100030:	e3a01000 	mov	r1, #0
		ldr r2,[r1]	
  100034:	e5912000 	ldr	r2, [r1]
		/* xor value from address 0 (flip all bits), store in R3 */
		ldr r3,=0xffffffff
  100038:	e3e03000 	mvn	r3, #0
		eor r3, r2, r3
  10003c:	e0223003 	eor	r3, r2, r3
		/* write xored value to first word in RAM 
		if already remapped this will also change
		the value at 0 */
		str r3,[r0]
  100040:	e5803000 	str	r3, [r0]
		/* load from address 0 again into R3 */
		ldr r3,[r1]
  100044:	e5913000 	ldr	r3, [r1]
		/* restore first value in RAM */
		str r4,[r0]
  100048:	e5804000 	str	r4, [r0]
		
		/* compare */
		cmp r3, r2
  10004c:	e1530002 	cmp	r3, r2
		bne already_remapped
  100050:	1a000002 	bne	100060 <already_remapped>
	
		/* if both values have been equal the change of the
		RAM-value had no effect on the value at 0x00000000 
		so we are not remapping yet -> remap now: */
		LDR     R0, =MC_BASE
  100054:	e3e000ff 	mvn	r0, #255	; 0xff
		MOV     R1, #1
  100058:	e3a01001 	mov	r1, #1
		STR     R1, [R0, #MC_RCR]	
  10005c:	e5801000 	str	r1, [r0]

00100060 <already_remapped>:
/*------------------------------------------------------------------------------*/
            .extern   AT91F_LowLevelInit
/*- minumum C initialization */
/*- call  AT91F_LowLevelInit( void) */

            ldr     r13,.RAM_TOP            /* temporary stack in internal RAM (**) */
  100060:	e51fd044 	ldr	sp, [pc, #-68]	; 100024 <.RAM_TOP>
/*--Call Low level init function in ABSOLUTE through the Interworking	*/
            ldr     r0,=AT91F_LowLevelInit
  100064:	e59f0098 	ldr	r0, [pc, #152]	; 100104 <exit+0xc>
            mov     lr, pc
  100068:	e1a0e00f 	mov	lr, pc
            bx      r0
  10006c:	e12fff10 	bx	r0
          .EQU		F_BIT,              0x40

/*------------------------------------------------------------------------------
//*- Setup the stack for each mode
//*-------------------------------*/
                mov     r0,r13 /* see (**) */
  100070:	e1a0000d 	mov	r0, sp

/*- Set up Fast Interrupt Mode and set FIQ Mode Stack*/
                msr     CPSR_c, #ARM_MODE_FIQ | I_BIT | F_BIT
  100074:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
/*- Init the FIQ register*/
                ldr     r8, =AT91C_BASE_AIC
  100078:	e59f8088 	ldr	r8, [pc, #136]	; 100108 <exit+0x10>

/*- Set up Interrupt Mode and set IRQ Mode Stack*/
                msr     CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT
  10007c:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
                mov     r13, r0                     /* Init stack IRQ */
  100080:	e1a0d000 	mov	sp, r0
                sub     r0, r0, #IRQ_STACK_SIZE
  100084:	e2400060 	sub	r0, r0, #96	; 0x60

/*- Set up Supervisor Mode and set Supervisor Mode Stack*/
				/* start with INT and FIQ enabled */
				msr     CPSR_c, #ARM_MODE_SVC 
  100088:	e321f013 	msr	CPSR_c, #19

//				/* start with INT and FIQ disabled */
//				msr     CPSR_c, #ARM_MODE_SVC | I_BIT | F_BIT 

				mov     r13, r0                     /* Init stack Sup */
  10008c:	e1a0d000 	mov	sp, r0


/*- Enable interrupt & Set up Supervisor Mode and set Supervisor Mode Stack*/

/* Relocate .data section (Copy from ROM to RAM) */
                LDR     R1, =_etext
  100090:	e59f1074 	ldr	r1, [pc, #116]	; 10010c <exit+0x14>
                LDR     R2, =_data
  100094:	e59f2074 	ldr	r2, [pc, #116]	; 100110 <exit+0x18>
                LDR     R3, =_edata
  100098:	e59f3074 	ldr	r3, [pc, #116]	; 100114 <exit+0x1c>

0010009c <LoopRel>:
LoopRel:        CMP     R2, R3
  10009c:	e1520003 	cmp	r2, r3
                LDRLO   R0, [R1], #4
  1000a0:	34910004 	ldrcc	r0, [r1], #4
                STRLO   R0, [R2], #4
  1000a4:	34820004 	strcc	r0, [r2], #4
                BLO     LoopRel
  1000a8:	3afffffb 	bcc	10009c <LoopRel>

/* Clear .bss section (Zero init) */
                MOV     R0, #0
  1000ac:	e3a00000 	mov	r0, #0
                LDR     R1, =__bss_start__
  1000b0:	e59f1060 	ldr	r1, [pc, #96]	; 100118 <exit+0x20>
                LDR     R2, =__bss_end__
  1000b4:	e59f2060 	ldr	r2, [pc, #96]	; 10011c <exit+0x24>

001000b8 <LoopZI>:
LoopZI:         CMP     R1, R2
  1000b8:	e1510002 	cmp	r1, r2
                STRLO   R0, [R1], #4
  1000bc:	34810004 	strcc	r0, [r1], #4
                BLO     LoopZI
  1000c0:	3afffffc 	bcc	1000b8 <LoopZI>


/* call C++ constructors of global objects */
		LDR 	r0, =__ctors_start__
  1000c4:	e59f0054 	ldr	r0, [pc, #84]	; 100120 <exit+0x28>
		LDR 	r1, =__ctors_end__
  1000c8:	e59f1054 	ldr	r1, [pc, #84]	; 100124 <exit+0x2c>

001000cc <ctor_loop>:
ctor_loop:
		CMP 	r0, r1
  1000cc:	e1500001 	cmp	r0, r1
		BEQ 	ctor_end
  1000d0:	0a000005 	beq	1000ec <ctor_end>
		LDR 	r2, [r0], #4
  1000d4:	e4902004 	ldr	r2, [r0], #4
		STMFD 	sp!, {r0-r1}
  1000d8:	e92d0003 	push	{r0, r1}
		MOV 	lr, pc
  1000dc:	e1a0e00f 	mov	lr, pc
/*		MOV 	pc, r2 */
		BX r2 /* mthomas 8/2006 */
  1000e0:	e12fff12 	bx	r2
		LDMFD 	sp!, {r0-r1}
  1000e4:	e8bd0003 	pop	{r0, r1}
		B 		ctor_loop
  1000e8:	eafffff7 	b	1000cc <ctor_loop>

001000ec <ctor_end>:
ctor_end:


/* call main() */
		ldr	lr,=exit
  1000ec:	e59fe034 	ldr	lr, [pc, #52]	; 100128 <exit+0x30>
		ldr	r0,=main
  1000f0:	e59f0034 	ldr	r0, [pc, #52]	; 10012c <exit+0x34>
		bx	r0
  1000f4:	e12fff10 	bx	r0

001000f8 <exit>:
/* "exit" dummy added by mthomas to avoid sbrk write read etc. needed
   by the newlib default "exit" */
        .global exit
        .func   exit
exit:
        b    .
  1000f8:	eafffffe 	b	1000f8 <exit>
  1000fc:	00100020 	.word	0x00100020
  100100:	00200000 	.word	0x00200000
  100104:	00100130 	.word	0x00100130
  100108:	fffff000 	.word	0xfffff000
  10010c:	00101f14 	.word	0x00101f14
  100110:	00200000 	.word	0x00200000
  100114:	002001d0 	.word	0x002001d0
  100118:	002001d0 	.word	0x002001d0
  10011c:	002002b8 	.word	0x002002b8
  100120:	00101f14 	.word	0x00101f14
  100124:	00101f14 	.word	0x00101f14
  100128:	001000f8 	.word	0x001000f8
  10012c:	00100428 	.word	0x00100428

00100130 <AT91F_LowLevelInit>:
//* \brief This function performs very low level HW initialization
//*        this function can use a Stack, depending the compilation
//*        optimization mode
//*----------------------------------------------------------------------------
//void AT91F_LowLevelInit(void) @ "ICODE"
void AT91F_LowLevelInit(void) {
  100130:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  100134:	e28db000 	add	fp, sp, #0
  100138:	e24dd00c 	sub	sp, sp, #12
    unsigned char i;
    ///////////////////////////////////////////////////////////////////////////
    // EFC Init
    ///////////////////////////////////////////////////////////////////////////
    AT91C_BASE_MC->MC_FMR = AT91C_MC_FWS_1FWS ;
  10013c:	e3e030ff 	mvn	r3, #255	; 0xff
  100140:	e3a02c01 	mov	r2, #256	; 0x100
  100144:	e5832060 	str	r2, [r3, #96]	; 0x60
    // Main Oscillator Startup Time worst case (3MHz) corresponds to 15ms
    // (0x40 for AT91C_CKGR_OSCOUNT field)
    ///////////////////////////////////////////////////////////////////////////
    // mtmt avoid warning operator - precedence & > | 
    // AT91C_BASE_PMC->PMC_MOR = (( AT91C_CKGR_OSCOUNT & (0x40 <<8) | AT91C_CKGR_MOSCEN ));
    AT91C_BASE_PMC->PMC_MOR = ( ( ( AT91C_CKGR_OSCOUNT & (0x40 <<8) ) | AT91C_CKGR_MOSCEN ));
  100148:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  10014c:	e1a03ac3 	asr	r3, r3, #21
  100150:	e3a02901 	mov	r2, #16384	; 0x4000
  100154:	e2822001 	add	r2, r2, #1
  100158:	e5832020 	str	r2, [r3, #32]
    // Wait Main Oscillator stabilization
    while(!(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MOSCS));
  10015c:	e1a00000 	nop			; (mov r0, r0)
  100160:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  100164:	e1a03ac3 	asr	r3, r3, #21
  100168:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  10016c:	e2033001 	and	r3, r3, #1
  100170:	e3530000 	cmp	r3, #0
  100174:	0afffff9 	beq	100160 <AT91F_LowLevelInit+0x30>
    // Set PLL to 96MHz (96,109MHz) and UDP Clock to 48MHz
    // PLL Startup time depends on PLL RC filter: worst case is choosen
    // UDP Clock (48,058MHz) is compliant with the Universal Serial Bus
    // Specification (+/- 0.25% for full speed)
    ///////////////////////////////////////////////////////////////////////////
    AT91C_BASE_PMC->PMC_PLLR = AT91C_CKGR_USBDIV_1           |
  100178:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
  10017c:	e1a02ac2 	asr	r2, r2, #21
  100180:	e3a03541 	mov	r3, #272629760	; 0x10400000
  100184:	e2833a81 	add	r3, r3, #528384	; 0x81000
  100188:	e283300e 	add	r3, r3, #14
  10018c:	e582302c 	str	r3, [r2, #44]	; 0x2c
                               (16 << 8)                     |
                               (AT91C_CKGR_MUL & (72 << 16)) |
                               (AT91C_CKGR_DIV & 14);
    // Wait for PLL stabilization
    while( !(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_LOCK) );
  100190:	e1a00000 	nop			; (mov r0, r0)
  100194:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  100198:	e1a03ac3 	asr	r3, r3, #21
  10019c:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  1001a0:	e2033004 	and	r3, r3, #4
  1001a4:	e3530000 	cmp	r3, #0
  1001a8:	0afffff9 	beq	100194 <AT91F_LowLevelInit+0x64>
    // Wait until the master clock is established for the case we already
    // turn on the PLL
    while( !(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MCKRDY) );
  1001ac:	e1a00000 	nop			; (mov r0, r0)
  1001b0:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1001b4:	e1a03ac3 	asr	r3, r3, #21
  1001b8:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  1001bc:	e2033008 	and	r3, r3, #8
  1001c0:	e3530000 	cmp	r3, #0
  1001c4:	0afffff9 	beq	1001b0 <AT91F_LowLevelInit+0x80>
    // Init PMC Step 3.
    // Selection of Master Clock MCK equal to (Processor Clock PCK) PLL/2=48MHz
    // The PMC_MCKR register must not be programmed in a single write operation
    // (see. Product Errata Sheet)
    ///////////////////////////////////////////////////////////////////////////
    AT91C_BASE_PMC->PMC_MCKR = AT91C_PMC_PRES_CLK_2;
  1001c8:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1001cc:	e1a03ac3 	asr	r3, r3, #21
  1001d0:	e3a02004 	mov	r2, #4
  1001d4:	e5832030 	str	r2, [r3, #48]	; 0x30
    // Wait until the master clock is established
    while( !(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MCKRDY) );
  1001d8:	e1a00000 	nop			; (mov r0, r0)
  1001dc:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1001e0:	e1a03ac3 	asr	r3, r3, #21
  1001e4:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  1001e8:	e2033008 	and	r3, r3, #8
  1001ec:	e3530000 	cmp	r3, #0
  1001f0:	0afffff9 	beq	1001dc <AT91F_LowLevelInit+0xac>

    AT91C_BASE_PMC->PMC_MCKR |= AT91C_PMC_CSS_PLL_CLK;
  1001f4:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1001f8:	e1a03ac3 	asr	r3, r3, #21
  1001fc:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
  100200:	e1a02ac2 	asr	r2, r2, #21
  100204:	e5922030 	ldr	r2, [r2, #48]	; 0x30
  100208:	e3822003 	orr	r2, r2, #3
  10020c:	e5832030 	str	r2, [r3, #48]	; 0x30
    // Wait until the master clock is established
    while( !(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MCKRDY) );
  100210:	e1a00000 	nop			; (mov r0, r0)
  100214:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  100218:	e1a03ac3 	asr	r3, r3, #21
  10021c:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  100220:	e2033008 	and	r3, r3, #8
  100224:	e3530000 	cmp	r3, #0
  100228:	0afffff9 	beq	100214 <AT91F_LowLevelInit+0xe4>

    ///////////////////////////////////////////////////////////////////////////
    //  Disable Watchdog (write once register)
    ///////////////////////////////////////////////////////////////////////////
    AT91C_BASE_WDTC->WDTC_WDMR = AT91C_WDTC_WDDIS;
  10022c:	e3a0332a 	mov	r3, #-1476395008	; 0xa8000000
  100230:	e1a03ac3 	asr	r3, r3, #21
  100234:	e3a02902 	mov	r2, #32768	; 0x8000
  100238:	e5832004 	str	r2, [r3, #4]

    ///////////////////////////////////////////////////////////////////////////
    //  Init AIC: assign corresponding handler for each interrupt source
    ///////////////////////////////////////////////////////////////////////////
    AT91C_BASE_AIC->AIC_SVR[0] = (int) AT91F_Default_FIQ_handler ;
  10023c:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  100240:	e1a039c3 	asr	r3, r3, #19
  100244:	e59f2058 	ldr	r2, [pc, #88]	; 1002a4 <AT91F_LowLevelInit+0x174>
  100248:	e5832080 	str	r2, [r3, #128]	; 0x80
    for (i = 1; i < 31; i++) {
  10024c:	e3a03001 	mov	r3, #1
  100250:	e54b3005 	strb	r3, [fp, #-5]
  100254:	ea000008 	b	10027c <AT91F_LowLevelInit+0x14c>
        AT91C_BASE_AIC->AIC_SVR[i] = (int) AT91F_Default_IRQ_handler ;
  100258:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  10025c:	e1a039c3 	asr	r3, r3, #19
  100260:	e55b2005 	ldrb	r2, [fp, #-5]
  100264:	e59f103c 	ldr	r1, [pc, #60]	; 1002a8 <AT91F_LowLevelInit+0x178>
  100268:	e2822020 	add	r2, r2, #32
  10026c:	e7831102 	str	r1, [r3, r2, lsl #2]

    ///////////////////////////////////////////////////////////////////////////
    //  Init AIC: assign corresponding handler for each interrupt source
    ///////////////////////////////////////////////////////////////////////////
    AT91C_BASE_AIC->AIC_SVR[0] = (int) AT91F_Default_FIQ_handler ;
    for (i = 1; i < 31; i++) {
  100270:	e55b3005 	ldrb	r3, [fp, #-5]
  100274:	e2833001 	add	r3, r3, #1
  100278:	e54b3005 	strb	r3, [fp, #-5]
  10027c:	e55b3005 	ldrb	r3, [fp, #-5]
  100280:	e353001e 	cmp	r3, #30
  100284:	9afffff3 	bls	100258 <AT91F_LowLevelInit+0x128>
        AT91C_BASE_AIC->AIC_SVR[i] = (int) AT91F_Default_IRQ_handler ;
    }
    AT91C_BASE_AIC->AIC_SPU = (unsigned int) AT91F_Spurious_handler;
  100288:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  10028c:	e1a039c3 	asr	r3, r3, #19
  100290:	e59f2014 	ldr	r2, [pc, #20]	; 1002ac <AT91F_LowLevelInit+0x17c>
  100294:	e5832134 	str	r2, [r3, #308]	; 0x134
}
  100298:	e28bd000 	add	sp, fp, #0
  10029c:	e8bd0800 	pop	{fp}
  1002a0:	e12fff1e 	bx	lr
  1002a4:	002000b8 	.word	0x002000b8
  1002a8:	002000bc 	.word	0x002000bc
  1002ac:	002000c0 	.word	0x002000c0

001002b0 <SWI_Handler_User>:

unsigned long SWI_Handler_User(unsigned long reg0,
	unsigned long reg1,
	unsigned long reg2,
	unsigned long swi_num )
{
  1002b0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1002b4:	e28db000 	add	fp, sp, #0
  1002b8:	e24dd01c 	sub	sp, sp, #28
  1002bc:	e50b0010 	str	r0, [fp, #-16]
  1002c0:	e50b1014 	str	r1, [fp, #-20]
  1002c4:	e50b2018 	str	r2, [fp, #-24]
  1002c8:	e50b301c 	str	r3, [fp, #-28]
	unsigned long res;

	res = 0;
  1002cc:	e3a03000 	mov	r3, #0
  1002d0:	e50b3008 	str	r3, [fp, #-8]
	
	return res;
  1002d4:	e51b3008 	ldr	r3, [fp, #-8]
}
  1002d8:	e1a00003 	mov	r0, r3
  1002dc:	e28bd000 	add	sp, fp, #0
  1002e0:	e8bd0800 	pop	{fp}
  1002e4:	e12fff1e 	bx	lr

001002e8 <AT91F_PIO_CfgOutput>:
//* \brief Enable PIO in output mode
//*----------------------------------------------------------------------------
__inline void AT91F_PIO_CfgOutput(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int pioEnable)      // \arg PIO to be enabled
{
  1002e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1002ec:	e28db000 	add	fp, sp, #0
  1002f0:	e24dd00c 	sub	sp, sp, #12
  1002f4:	e50b0008 	str	r0, [fp, #-8]
  1002f8:	e50b100c 	str	r1, [fp, #-12]
	pPio->PIO_PER = pioEnable; // Set in PIO mode
  1002fc:	e51b3008 	ldr	r3, [fp, #-8]
  100300:	e51b200c 	ldr	r2, [fp, #-12]
  100304:	e5832000 	str	r2, [r3]
	pPio->PIO_OER = pioEnable; // Configure in Output
  100308:	e51b3008 	ldr	r3, [fp, #-8]
  10030c:	e51b200c 	ldr	r2, [fp, #-12]
  100310:	e5832010 	str	r2, [r3, #16]
}
  100314:	e28bd000 	add	sp, fp, #0
  100318:	e8bd0800 	pop	{fp}
  10031c:	e12fff1e 	bx	lr

00100320 <AT91F_PIO_SetOutput>:
//* \brief Set to 1 output PIO
//*----------------------------------------------------------------------------
__inline void AT91F_PIO_SetOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be set
{
  100320:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  100324:	e28db000 	add	fp, sp, #0
  100328:	e24dd00c 	sub	sp, sp, #12
  10032c:	e50b0008 	str	r0, [fp, #-8]
  100330:	e50b100c 	str	r1, [fp, #-12]
	pPio->PIO_SODR = flag;
  100334:	e51b3008 	ldr	r3, [fp, #-8]
  100338:	e51b200c 	ldr	r2, [fp, #-12]
  10033c:	e5832030 	str	r2, [r3, #48]	; 0x30
}
  100340:	e28bd000 	add	sp, fp, #0
  100344:	e8bd0800 	pop	{fp}
  100348:	e12fff1e 	bx	lr

0010034c <AT91F_PIO_ClearOutput>:
//* \brief Set to 0 output PIO
//*----------------------------------------------------------------------------
__inline void AT91F_PIO_ClearOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be cleared
{
  10034c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  100350:	e28db000 	add	fp, sp, #0
  100354:	e24dd00c 	sub	sp, sp, #12
  100358:	e50b0008 	str	r0, [fp, #-8]
  10035c:	e50b100c 	str	r1, [fp, #-12]
	pPio->PIO_CODR = flag;
  100360:	e51b3008 	ldr	r3, [fp, #-8]
  100364:	e51b200c 	ldr	r2, [fp, #-12]
  100368:	e5832034 	str	r2, [r3, #52]	; 0x34
}
  10036c:	e28bd000 	add	sp, fp, #0
  100370:	e8bd0800 	pop	{fp}
  100374:	e12fff1e 	bx	lr

00100378 <AT91F_PMC_EnablePeriphClock>:
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
__inline void AT91F_PMC_EnablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals
{
  100378:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10037c:	e28db000 	add	fp, sp, #0
  100380:	e24dd00c 	sub	sp, sp, #12
  100384:	e50b0008 	str	r0, [fp, #-8]
  100388:	e50b100c 	str	r1, [fp, #-12]
	pPMC->PMC_PCER = periphIds;
  10038c:	e51b3008 	ldr	r3, [fp, #-8]
  100390:	e51b200c 	ldr	r2, [fp, #-12]
  100394:	e5832010 	str	r2, [r3, #16]
}
  100398:	e28bd000 	add	sp, fp, #0
  10039c:	e8bd0800 	pop	{fp}
  1003a0:	e12fff1e 	bx	lr

001003a4 <AT91F_USB_Open>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_USB_Open
//* \brief This function Open the USB device
//*----------------------------------------------------------------------------
void AT91F_USB_Open(void)
{
  1003a4:	e92d4800 	push	{fp, lr}
  1003a8:	e28db004 	add	fp, sp, #4
    // Set the PLL USB Divider
    AT91C_BASE_CKGR->CKGR_PLLR |= AT91C_CKGR_USBDIV_1 ;
  1003ac:	e3a03321 	mov	r3, #-2080374784	; 0x84000000
  1003b0:	e1a03ac3 	asr	r3, r3, #21
  1003b4:	e3a02321 	mov	r2, #-2080374784	; 0x84000000
  1003b8:	e1a02ac2 	asr	r2, r2, #21
  1003bc:	e592200c 	ldr	r2, [r2, #12]
  1003c0:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
  1003c4:	e583200c 	str	r2, [r3, #12]

    // Specific Chip USB Initialisation
    // Enables the 48MHz USB clock UDPCK and System Peripheral USB Clock
    AT91C_BASE_PMC->PMC_SCER = AT91C_PMC_UDP;
  1003c8:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1003cc:	e1a03ac3 	asr	r3, r3, #21
  1003d0:	e3a02080 	mov	r2, #128	; 0x80
  1003d4:	e5832000 	str	r2, [r3]
    AT91C_BASE_PMC->PMC_PCER = (1 << AT91C_ID_UDP);
  1003d8:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1003dc:	e1a03ac3 	asr	r3, r3, #21
  1003e0:	e3a02b02 	mov	r2, #2048	; 0x800
  1003e4:	e5832010 	str	r2, [r3, #16]

    // Enable UDP PullUp (USB_DP_PUP) : enable & Clear of the corresponding PIO
    // Set in PIO mode and Configure in Output
    AT91F_PIO_CfgOutput(AT91C_BASE_PIOA,AT91C_PIO_PA16);
  1003e8:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  1003ec:	e1a009c0 	asr	r0, r0, #19
  1003f0:	e3a01801 	mov	r1, #65536	; 0x10000
  1003f4:	ebffffbb 	bl	1002e8 <AT91F_PIO_CfgOutput>
    // Clear for set the Pul up resistor
    AT91F_PIO_ClearOutput(AT91C_BASE_PIOA,AT91C_PIO_PA16);
  1003f8:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  1003fc:	e1a009c0 	asr	r0, r0, #19
  100400:	e3a01801 	mov	r1, #65536	; 0x10000
  100404:	ebffffd0 	bl	10034c <AT91F_PIO_ClearOutput>

    // CDC Open by structure initialization
    AT91F_CDC_Open(&pCDC, AT91C_BASE_UDP);
  100408:	e59f0014 	ldr	r0, [pc, #20]	; 100424 <AT91F_USB_Open+0x80>
  10040c:	e3a0120b 	mov	r1, #-1342177280	; 0xb0000000
  100410:	e1a01641 	asr	r1, r1, #12
  100414:	eb000047 	bl	100538 <AT91F_CDC_Open>
}
  100418:	e24bd004 	sub	sp, fp, #4
  10041c:	e8bd4800 	pop	{fp, lr}
  100420:	e12fff1e 	bx	lr
  100424:	0020029c 	.word	0x0020029c

00100428 <main>:
//*--------------------------------------------------------------------------------------
//* Function Name       : main
//* Object              :
//*--------------------------------------------------------------------------------------
int main ( void )
{
  100428:	e92d4800 	push	{fp, lr}
  10042c:	e28db004 	add	fp, sp, #4
  100430:	e24dde3f 	sub	sp, sp, #1008	; 0x3f0
	char data[MSG_SIZE];
	unsigned int length;
     // Enable User Reset and set its minimal assertion to 960 us
     AT91C_BASE_RSTC->RSTC_RMR = AT91C_RSTC_URSTEN | (0x4<<8) | (unsigned int)(0xA5<<24);
  100434:	e3a0220a 	mov	r2, #-1610612736	; 0xa0000000
  100438:	e1a02ac2 	asr	r2, r2, #21
  10043c:	e3a034a5 	mov	r3, #-1526726656	; 0xa5000000
  100440:	e2833b01 	add	r3, r3, #1024	; 0x400
  100444:	e2833001 	add	r3, r3, #1
  100448:	e5823008 	str	r3, [r2, #8]
   // Led init
   // First, enable the clock of the PIOB
     AT91F_PMC_EnablePeriphClock ( AT91C_BASE_PMC, 1 << AT91C_ID_PIOA ) ;
  10044c:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  100450:	e1a00ac0 	asr	r0, r0, #21
  100454:	e3a01004 	mov	r1, #4
  100458:	ebffffc6 	bl	100378 <AT91F_PMC_EnablePeriphClock>
   //* to be outputs. No need to set these pins to be driven by the PIO because it is GPIO pins only.
     AT91F_PIO_CfgOutput( AT91C_BASE_PIOA, AT91B_LED_MASK ) ;
  10045c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100460:	e1a009c0 	asr	r0, r0, #19
  100464:	e3a01806 	mov	r1, #393216	; 0x60000
  100468:	ebffff9e 	bl	1002e8 <AT91F_PIO_CfgOutput>
   //* Clear the LED's.
    AT91F_PIO_SetOutput( AT91C_BASE_PIOA, AT91B_LED_MASK ) ;
  10046c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100470:	e1a009c0 	asr	r0, r0, #19
  100474:	e3a01806 	mov	r1, #393216	; 0x60000
  100478:	ebffffa8 	bl	100320 <AT91F_PIO_SetOutput>
   //* Set led 1e LED's.
    AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, AT91B_LED1 ) ;
  10047c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100480:	e1a009c0 	asr	r0, r0, #19
  100484:	e3a01701 	mov	r1, #262144	; 0x40000
  100488:	ebffffaf 	bl	10034c <AT91F_PIO_ClearOutput>

    // Init USB device
   AT91F_USB_Open();
  10048c:	ebffffc4 	bl	1003a4 <AT91F_USB_Open>
    
    // Init USB device
    // Wait for the end of enumeration
   while (!pCDC.IsConfigured(&pCDC));
  100490:	e1a00000 	nop			; (mov r0, r0)
  100494:	e59f3098 	ldr	r3, [pc, #152]	; 100534 <main+0x10c>
  100498:	e593300c 	ldr	r3, [r3, #12]
  10049c:	e59f0090 	ldr	r0, [pc, #144]	; 100534 <main+0x10c>
  1004a0:	e1a0e00f 	mov	lr, pc
  1004a4:	e12fff13 	bx	r3
  1004a8:	e1a03000 	mov	r3, r0
  1004ac:	e3530000 	cmp	r3, #0
  1004b0:	0afffff7 	beq	100494 <main+0x6c>
    
  //* Set led 1e LED's.
    AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, AT91B_LED1 ) ;
  1004b4:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  1004b8:	e1a009c0 	asr	r0, r0, #19
  1004bc:	e3a01701 	mov	r1, #262144	; 0x40000
  1004c0:	ebffffa1 	bl	10034c <AT91F_PIO_ClearOutput>
    // Set Usart in interrupt
    Usart_init();
  1004c4:	eb0005ec 	bl	101c7c <Usart_init>
   //* Set led all LED's.
    AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, AT91B_LED_MASK ) ;
  1004c8:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  1004cc:	e1a009c0 	asr	r0, r0, #19
  1004d0:	e3a01806 	mov	r1, #393216	; 0x60000
  1004d4:	ebffff9c 	bl	10034c <AT91F_PIO_ClearOutput>

   while (1)
   {       // Loop
	length = pCDC.Read(&pCDC, data, MSG_SIZE);
  1004d8:	e59f3054 	ldr	r3, [pc, #84]	; 100534 <main+0x10c>
  1004dc:	e5933014 	ldr	r3, [r3, #20]
  1004e0:	e24b2e3f 	sub	r2, fp, #1008	; 0x3f0
  1004e4:	e59f0048 	ldr	r0, [pc, #72]	; 100534 <main+0x10c>
  1004e8:	e1a01002 	mov	r1, r2
  1004ec:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  1004f0:	e1a0e00f 	mov	lr, pc
  1004f4:	e12fff13 	bx	r3
  1004f8:	e50b0008 	str	r0, [fp, #-8]
  	 data[length]=0;
  1004fc:	e3a03000 	mov	r3, #0
  100500:	e2433ffb 	sub	r3, r3, #1004	; 0x3ec
  100504:	e51b2008 	ldr	r2, [fp, #-8]
  100508:	e24b1004 	sub	r1, fp, #4
  10050c:	e0812002 	add	r2, r1, r2
  100510:	e0823003 	add	r3, r2, r3
  100514:	e3a02000 	mov	r2, #0
  100518:	e5c32000 	strb	r2, [r3]
	  Trace_Toggel_LED( AT91B_LED1) ; 
  10051c:	e3a00701 	mov	r0, #262144	; 0x40000
  100520:	eb00051a 	bl	101990 <Trace_Toggel_LED>
          AT91F_US_Put(data);
  100524:	e24b3e3f 	sub	r3, fp, #1008	; 0x3f0
  100528:	e1a00003 	mov	r0, r3
  10052c:	eb0005b3 	bl	101c00 <AT91F_US_Put>
   }
  100530:	eaffffe8 	b	1004d8 <main+0xb0>
  100534:	0020029c 	.word	0x0020029c

00100538 <AT91F_CDC_Open>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_CDC_Open
//* \brief
//*----------------------------------------------------------------------------
AT91PS_CDC AT91F_CDC_Open(AT91PS_CDC pCdc, AT91PS_UDP pUdp)
{
  100538:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10053c:	e28db000 	add	fp, sp, #0
  100540:	e24dd00c 	sub	sp, sp, #12
  100544:	e50b0008 	str	r0, [fp, #-8]
  100548:	e50b100c 	str	r1, [fp, #-12]
	pCdc->pUdp = pUdp;
  10054c:	e51b3008 	ldr	r3, [fp, #-8]
  100550:	e51b200c 	ldr	r2, [fp, #-12]
  100554:	e5832000 	str	r2, [r3]
	pCdc->currentConfiguration = 0;
  100558:	e51b3008 	ldr	r3, [fp, #-8]
  10055c:	e3a02000 	mov	r2, #0
  100560:	e5c32004 	strb	r2, [r3, #4]
	pCdc->currentConnection    = 0;
  100564:	e51b3008 	ldr	r3, [fp, #-8]
  100568:	e3a02000 	mov	r2, #0
  10056c:	e5c32005 	strb	r2, [r3, #5]
	pCdc->currentRcvBank       = AT91C_UDP_RX_DATA_BK0;
  100570:	e51b3008 	ldr	r3, [fp, #-8]
  100574:	e3a02002 	mov	r2, #2
  100578:	e5832008 	str	r2, [r3, #8]
	pCdc->IsConfigured = AT91F_UDP_IsConfigured;
  10057c:	e51b3008 	ldr	r3, [fp, #-8]
  100580:	e59f202c 	ldr	r2, [pc, #44]	; 1005b4 <AT91F_CDC_Open+0x7c>
  100584:	e583200c 	str	r2, [r3, #12]
	pCdc->Write        = AT91F_UDP_Write;
  100588:	e51b3008 	ldr	r3, [fp, #-8]
  10058c:	e59f2024 	ldr	r2, [pc, #36]	; 1005b8 <AT91F_CDC_Open+0x80>
  100590:	e5832010 	str	r2, [r3, #16]
	pCdc->Read         = AT91F_UDP_Read;
  100594:	e51b3008 	ldr	r3, [fp, #-8]
  100598:	e59f201c 	ldr	r2, [pc, #28]	; 1005bc <AT91F_CDC_Open+0x84>
  10059c:	e5832014 	str	r2, [r3, #20]
	return pCdc;
  1005a0:	e51b3008 	ldr	r3, [fp, #-8]
}
  1005a4:	e1a00003 	mov	r0, r3
  1005a8:	e28bd000 	add	sp, fp, #0
  1005ac:	e8bd0800 	pop	{fp}
  1005b0:	e12fff1e 	bx	lr
  1005b4:	001005c0 	.word	0x001005c0
  1005b8:	00100800 	.word	0x00100800
  1005bc:	00100678 	.word	0x00100678

001005c0 <AT91F_UDP_IsConfigured>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_IsConfigured
//* \brief Test if the device is configured and handle enumeration
//*----------------------------------------------------------------------------
static uchar AT91F_UDP_IsConfigured(AT91PS_CDC pCdc)
{
  1005c0:	e92d4800 	push	{fp, lr}
  1005c4:	e28db004 	add	fp, sp, #4
  1005c8:	e24dd010 	sub	sp, sp, #16
  1005cc:	e50b0010 	str	r0, [fp, #-16]
	AT91PS_UDP pUDP = pCdc->pUdp;
  1005d0:	e51b3010 	ldr	r3, [fp, #-16]
  1005d4:	e5933000 	ldr	r3, [r3]
  1005d8:	e50b3008 	str	r3, [fp, #-8]
	AT91_REG isr = pUDP->UDP_ISR;
  1005dc:	e51b3008 	ldr	r3, [fp, #-8]
  1005e0:	e593301c 	ldr	r3, [r3, #28]
  1005e4:	e50b300c 	str	r3, [fp, #-12]

	if (isr & AT91C_UDP_ENDBUSRES) {
  1005e8:	e51b300c 	ldr	r3, [fp, #-12]
  1005ec:	e2033a01 	and	r3, r3, #4096	; 0x1000
  1005f0:	e3530000 	cmp	r3, #0
  1005f4:	0a00000f 	beq	100638 <AT91F_UDP_IsConfigured+0x78>
		pUDP->UDP_ICR = AT91C_UDP_ENDBUSRES;
  1005f8:	e51b3008 	ldr	r3, [fp, #-8]
  1005fc:	e3a02a01 	mov	r2, #4096	; 0x1000
  100600:	e5832020 	str	r2, [r3, #32]
		// reset all endpoints
		pUDP->UDP_RSTEP  = (unsigned int)-1;
  100604:	e51b3008 	ldr	r3, [fp, #-8]
  100608:	e3e02000 	mvn	r2, #0
  10060c:	e5832028 	str	r2, [r3, #40]	; 0x28
		pUDP->UDP_RSTEP  = 0;
  100610:	e51b3008 	ldr	r3, [fp, #-8]
  100614:	e3a02000 	mov	r2, #0
  100618:	e5832028 	str	r2, [r3, #40]	; 0x28
		// Enable the function
		pUDP->UDP_FADDR = AT91C_UDP_FEN;
  10061c:	e51b3008 	ldr	r3, [fp, #-8]
  100620:	e3a02c01 	mov	r2, #256	; 0x100
  100624:	e5832008 	str	r2, [r3, #8]
		// Configure endpoint 0
		pUDP->UDP_CSR[0] = (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_CTRL);
  100628:	e51b3008 	ldr	r3, [fp, #-8]
  10062c:	e3a02902 	mov	r2, #32768	; 0x8000
  100630:	e5832030 	str	r2, [r3, #48]	; 0x30
  100634:	ea000009 	b	100660 <AT91F_UDP_IsConfigured+0xa0>
	}
	else if (isr & AT91C_UDP_EPINT0) {
  100638:	e51b300c 	ldr	r3, [fp, #-12]
  10063c:	e2033001 	and	r3, r3, #1
  100640:	e20330ff 	and	r3, r3, #255	; 0xff
  100644:	e3530000 	cmp	r3, #0
  100648:	0a000004 	beq	100660 <AT91F_UDP_IsConfigured+0xa0>
		pUDP->UDP_ICR = AT91C_UDP_EPINT0;
  10064c:	e51b3008 	ldr	r3, [fp, #-8]
  100650:	e3a02001 	mov	r2, #1
  100654:	e5832020 	str	r2, [r3, #32]
		AT91F_CDC_Enumerate(pCdc);
  100658:	e51b0010 	ldr	r0, [fp, #-16]
  10065c:	eb00018b 	bl	100c90 <AT91F_CDC_Enumerate>
	}
	return pCdc->currentConfiguration;
  100660:	e51b3010 	ldr	r3, [fp, #-16]
  100664:	e5d33004 	ldrb	r3, [r3, #4]
}
  100668:	e1a00003 	mov	r0, r3
  10066c:	e24bd004 	sub	sp, fp, #4
  100670:	e8bd4800 	pop	{fp, lr}
  100674:	e12fff1e 	bx	lr

00100678 <AT91F_UDP_Read>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_Read
//* \brief Read available data from Endpoint OUT
//*----------------------------------------------------------------------------
static uint AT91F_UDP_Read(AT91PS_CDC pCdc, char *pData, uint length)
{
  100678:	e92d4800 	push	{fp, lr}
  10067c:	e28db004 	add	fp, sp, #4
  100680:	e24dd020 	sub	sp, sp, #32
  100684:	e50b0018 	str	r0, [fp, #-24]
  100688:	e50b101c 	str	r1, [fp, #-28]
  10068c:	e50b2020 	str	r2, [fp, #-32]
	AT91PS_UDP pUdp = pCdc->pUdp;
  100690:	e51b3018 	ldr	r3, [fp, #-24]
  100694:	e5933000 	ldr	r3, [r3]
  100698:	e50b3014 	str	r3, [fp, #-20]
	uint packetSize, nbBytesRcv = 0, currentReceiveBank = pCdc->currentRcvBank;
  10069c:	e3a03000 	mov	r3, #0
  1006a0:	e50b300c 	str	r3, [fp, #-12]
  1006a4:	e51b3018 	ldr	r3, [fp, #-24]
  1006a8:	e5933008 	ldr	r3, [r3, #8]
  1006ac:	e50b3010 	str	r3, [fp, #-16]

	while (length) {
  1006b0:	ea000045 	b	1007cc <AT91F_UDP_Read+0x154>
		if ( !AT91F_UDP_IsConfigured(pCdc) )
  1006b4:	e51b0018 	ldr	r0, [fp, #-24]
  1006b8:	ebffffc0 	bl	1005c0 <AT91F_UDP_IsConfigured>
  1006bc:	e1a03000 	mov	r3, r0
  1006c0:	e3530000 	cmp	r3, #0
  1006c4:	0a000044 	beq	1007dc <AT91F_UDP_Read+0x164>
			break;
		if ( pUdp->UDP_CSR[AT91C_EP_OUT] & currentReceiveBank ) {
  1006c8:	e51b3014 	ldr	r3, [fp, #-20]
  1006cc:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  1006d0:	e51b3010 	ldr	r3, [fp, #-16]
  1006d4:	e0023003 	and	r3, r2, r3
  1006d8:	e3530000 	cmp	r3, #0
  1006dc:	0a00003a 	beq	1007cc <AT91F_UDP_Read+0x154>
			packetSize = MIN(pUdp->UDP_CSR[AT91C_EP_OUT] >> 16, length);
  1006e0:	e51b3014 	ldr	r3, [fp, #-20]
  1006e4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1006e8:	e1a02823 	lsr	r2, r3, #16
  1006ec:	e51b3020 	ldr	r3, [fp, #-32]
  1006f0:	e1520003 	cmp	r2, r3
  1006f4:	2a000003 	bcs	100708 <AT91F_UDP_Read+0x90>
  1006f8:	e51b3014 	ldr	r3, [fp, #-20]
  1006fc:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  100700:	e1a03823 	lsr	r3, r3, #16
  100704:	ea000000 	b	10070c <AT91F_UDP_Read+0x94>
  100708:	e51b3020 	ldr	r3, [fp, #-32]
  10070c:	e50b3008 	str	r3, [fp, #-8]
			length -= packetSize;
  100710:	e51b2020 	ldr	r2, [fp, #-32]
  100714:	e51b3008 	ldr	r3, [fp, #-8]
  100718:	e0633002 	rsb	r3, r3, r2
  10071c:	e50b3020 	str	r3, [fp, #-32]
			if (packetSize < AT91C_EP_OUT_SIZE)
  100720:	e51b3008 	ldr	r3, [fp, #-8]
  100724:	e353003f 	cmp	r3, #63	; 0x3f
  100728:	8a00000d 	bhi	100764 <AT91F_UDP_Read+0xec>
				length = 0;
  10072c:	e3a03000 	mov	r3, #0
  100730:	e50b3020 	str	r3, [fp, #-32]
			while(packetSize--)
  100734:	ea00000b 	b	100768 <AT91F_UDP_Read+0xf0>
				pData[nbBytesRcv++] = pUdp->UDP_FDR[AT91C_EP_OUT];
  100738:	e51b201c 	ldr	r2, [fp, #-28]
  10073c:	e51b300c 	ldr	r3, [fp, #-12]
  100740:	e0823003 	add	r3, r2, r3
  100744:	e51b2014 	ldr	r2, [fp, #-20]
  100748:	e5922054 	ldr	r2, [r2, #84]	; 0x54
  10074c:	e20220ff 	and	r2, r2, #255	; 0xff
  100750:	e5c32000 	strb	r2, [r3]
  100754:	e51b300c 	ldr	r3, [fp, #-12]
  100758:	e2833001 	add	r3, r3, #1
  10075c:	e50b300c 	str	r3, [fp, #-12]
  100760:	ea000000 	b	100768 <AT91F_UDP_Read+0xf0>
		if ( pUdp->UDP_CSR[AT91C_EP_OUT] & currentReceiveBank ) {
			packetSize = MIN(pUdp->UDP_CSR[AT91C_EP_OUT] >> 16, length);
			length -= packetSize;
			if (packetSize < AT91C_EP_OUT_SIZE)
				length = 0;
			while(packetSize--)
  100764:	e1a00000 	nop			; (mov r0, r0)
  100768:	e51b3008 	ldr	r3, [fp, #-8]
  10076c:	e3530000 	cmp	r3, #0
  100770:	03a03000 	moveq	r3, #0
  100774:	13a03001 	movne	r3, #1
  100778:	e20330ff 	and	r3, r3, #255	; 0xff
  10077c:	e51b2008 	ldr	r2, [fp, #-8]
  100780:	e2422001 	sub	r2, r2, #1
  100784:	e50b2008 	str	r2, [fp, #-8]
  100788:	e3530000 	cmp	r3, #0
  10078c:	1affffe9 	bne	100738 <AT91F_UDP_Read+0xc0>
				pData[nbBytesRcv++] = pUdp->UDP_FDR[AT91C_EP_OUT];
			pUdp->UDP_CSR[AT91C_EP_OUT] &= ~(currentReceiveBank);
  100790:	e51b3014 	ldr	r3, [fp, #-20]
  100794:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  100798:	e51b3010 	ldr	r3, [fp, #-16]
  10079c:	e1e03003 	mvn	r3, r3
  1007a0:	e0022003 	and	r2, r2, r3
  1007a4:	e51b3014 	ldr	r3, [fp, #-20]
  1007a8:	e5832034 	str	r2, [r3, #52]	; 0x34
			if (currentReceiveBank == AT91C_UDP_RX_DATA_BK0)
  1007ac:	e51b3010 	ldr	r3, [fp, #-16]
  1007b0:	e3530002 	cmp	r3, #2
  1007b4:	1a000002 	bne	1007c4 <AT91F_UDP_Read+0x14c>
				currentReceiveBank = AT91C_UDP_RX_DATA_BK1;
  1007b8:	e3a03040 	mov	r3, #64	; 0x40
  1007bc:	e50b3010 	str	r3, [fp, #-16]
  1007c0:	ea000001 	b	1007cc <AT91F_UDP_Read+0x154>
			else
				currentReceiveBank = AT91C_UDP_RX_DATA_BK0;
  1007c4:	e3a03002 	mov	r3, #2
  1007c8:	e50b3010 	str	r3, [fp, #-16]
static uint AT91F_UDP_Read(AT91PS_CDC pCdc, char *pData, uint length)
{
	AT91PS_UDP pUdp = pCdc->pUdp;
	uint packetSize, nbBytesRcv = 0, currentReceiveBank = pCdc->currentRcvBank;

	while (length) {
  1007cc:	e51b3020 	ldr	r3, [fp, #-32]
  1007d0:	e3530000 	cmp	r3, #0
  1007d4:	1affffb6 	bne	1006b4 <AT91F_UDP_Read+0x3c>
  1007d8:	ea000000 	b	1007e0 <AT91F_UDP_Read+0x168>
		if ( !AT91F_UDP_IsConfigured(pCdc) )
			break;
  1007dc:	e1a00000 	nop			; (mov r0, r0)
			else
				currentReceiveBank = AT91C_UDP_RX_DATA_BK0;

		}
	}
	pCdc->currentRcvBank = currentReceiveBank;
  1007e0:	e51b3018 	ldr	r3, [fp, #-24]
  1007e4:	e51b2010 	ldr	r2, [fp, #-16]
  1007e8:	e5832008 	str	r2, [r3, #8]
	return nbBytesRcv;
  1007ec:	e51b300c 	ldr	r3, [fp, #-12]

}
  1007f0:	e1a00003 	mov	r0, r3
  1007f4:	e24bd004 	sub	sp, fp, #4
  1007f8:	e8bd4800 	pop	{fp, lr}
  1007fc:	e12fff1e 	bx	lr

00100800 <AT91F_UDP_Write>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_CDC_Write
//* \brief Send through endpoint 2
//*----------------------------------------------------------------------------
static uint AT91F_UDP_Write(AT91PS_CDC pCdc, const char *pData, uint length)
{
  100800:	e92d4800 	push	{fp, lr}
  100804:	e28db004 	add	fp, sp, #4
  100808:	e24dd018 	sub	sp, sp, #24
  10080c:	e50b0010 	str	r0, [fp, #-16]
  100810:	e50b1014 	str	r1, [fp, #-20]
  100814:	e50b2018 	str	r2, [fp, #-24]
	AT91PS_UDP pUdp = pCdc->pUdp;
  100818:	e51b3010 	ldr	r3, [fp, #-16]
  10081c:	e5933000 	ldr	r3, [r3]
  100820:	e50b300c 	str	r3, [fp, #-12]
	uint cpt = 0;
  100824:	e3a03000 	mov	r3, #0
  100828:	e50b3008 	str	r3, [fp, #-8]

	// Send the first packet
	cpt = MIN(length, AT91C_EP_IN_SIZE);
  10082c:	e51b3018 	ldr	r3, [fp, #-24]
  100830:	e3530040 	cmp	r3, #64	; 0x40
  100834:	23a03040 	movcs	r3, #64	; 0x40
  100838:	e50b3008 	str	r3, [fp, #-8]
	length -= cpt;
  10083c:	e51b2018 	ldr	r2, [fp, #-24]
  100840:	e51b3008 	ldr	r3, [fp, #-8]
  100844:	e0633002 	rsb	r3, r3, r2
  100848:	e50b3018 	str	r3, [fp, #-24]
	while (cpt--) pUdp->UDP_FDR[AT91C_EP_IN] = *pData++;
  10084c:	ea000007 	b	100870 <AT91F_UDP_Write+0x70>
  100850:	e51b3014 	ldr	r3, [fp, #-20]
  100854:	e5d33000 	ldrb	r3, [r3]
  100858:	e1a02003 	mov	r2, r3
  10085c:	e51b300c 	ldr	r3, [fp, #-12]
  100860:	e5832058 	str	r2, [r3, #88]	; 0x58
  100864:	e51b3014 	ldr	r3, [fp, #-20]
  100868:	e2833001 	add	r3, r3, #1
  10086c:	e50b3014 	str	r3, [fp, #-20]
  100870:	e51b3008 	ldr	r3, [fp, #-8]
  100874:	e3530000 	cmp	r3, #0
  100878:	03a03000 	moveq	r3, #0
  10087c:	13a03001 	movne	r3, #1
  100880:	e20330ff 	and	r3, r3, #255	; 0xff
  100884:	e51b2008 	ldr	r2, [fp, #-8]
  100888:	e2422001 	sub	r2, r2, #1
  10088c:	e50b2008 	str	r2, [fp, #-8]
  100890:	e3530000 	cmp	r3, #0
  100894:	1affffed 	bne	100850 <AT91F_UDP_Write+0x50>
	pUdp->UDP_CSR[AT91C_EP_IN] |= AT91C_UDP_TXPKTRDY;
  100898:	e51b300c 	ldr	r3, [fp, #-12]
  10089c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  1008a0:	e3832010 	orr	r2, r3, #16
  1008a4:	e51b300c 	ldr	r3, [fp, #-12]
  1008a8:	e5832038 	str	r2, [r3, #56]	; 0x38

	while (length) {
  1008ac:	ea000038 	b	100994 <AT91F_UDP_Write+0x194>
		// Fill the second bank
		cpt = MIN(length, AT91C_EP_IN_SIZE);
  1008b0:	e51b3018 	ldr	r3, [fp, #-24]
  1008b4:	e3530040 	cmp	r3, #64	; 0x40
  1008b8:	23a03040 	movcs	r3, #64	; 0x40
  1008bc:	e50b3008 	str	r3, [fp, #-8]
		length -= cpt;
  1008c0:	e51b2018 	ldr	r2, [fp, #-24]
  1008c4:	e51b3008 	ldr	r3, [fp, #-8]
  1008c8:	e0633002 	rsb	r3, r3, r2
  1008cc:	e50b3018 	str	r3, [fp, #-24]
		while (cpt--) pUdp->UDP_FDR[AT91C_EP_IN] = *pData++;
  1008d0:	ea000007 	b	1008f4 <AT91F_UDP_Write+0xf4>
  1008d4:	e51b3014 	ldr	r3, [fp, #-20]
  1008d8:	e5d33000 	ldrb	r3, [r3]
  1008dc:	e1a02003 	mov	r2, r3
  1008e0:	e51b300c 	ldr	r3, [fp, #-12]
  1008e4:	e5832058 	str	r2, [r3, #88]	; 0x58
  1008e8:	e51b3014 	ldr	r3, [fp, #-20]
  1008ec:	e2833001 	add	r3, r3, #1
  1008f0:	e50b3014 	str	r3, [fp, #-20]
  1008f4:	e51b3008 	ldr	r3, [fp, #-8]
  1008f8:	e3530000 	cmp	r3, #0
  1008fc:	03a03000 	moveq	r3, #0
  100900:	13a03001 	movne	r3, #1
  100904:	e20330ff 	and	r3, r3, #255	; 0xff
  100908:	e51b2008 	ldr	r2, [fp, #-8]
  10090c:	e2422001 	sub	r2, r2, #1
  100910:	e50b2008 	str	r2, [fp, #-8]
  100914:	e3530000 	cmp	r3, #0
  100918:	1affffed 	bne	1008d4 <AT91F_UDP_Write+0xd4>
		// Wait for the the first bank to be sent
		while ( !(pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP) )
  10091c:	ea000006 	b	10093c <AT91F_UDP_Write+0x13c>
			if ( !AT91F_UDP_IsConfigured(pCdc) ) return length;
  100920:	e51b0010 	ldr	r0, [fp, #-16]
  100924:	ebffff25 	bl	1005c0 <AT91F_UDP_IsConfigured>
  100928:	e1a03000 	mov	r3, r0
  10092c:	e3530000 	cmp	r3, #0
  100930:	1a000001 	bne	10093c <AT91F_UDP_Write+0x13c>
  100934:	e51b3018 	ldr	r3, [fp, #-24]
  100938:	ea000032 	b	100a08 <AT91F_UDP_Write+0x208>
		// Fill the second bank
		cpt = MIN(length, AT91C_EP_IN_SIZE);
		length -= cpt;
		while (cpt--) pUdp->UDP_FDR[AT91C_EP_IN] = *pData++;
		// Wait for the the first bank to be sent
		while ( !(pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP) )
  10093c:	e51b300c 	ldr	r3, [fp, #-12]
  100940:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  100944:	e2033001 	and	r3, r3, #1
  100948:	e3530000 	cmp	r3, #0
  10094c:	0afffff3 	beq	100920 <AT91F_UDP_Write+0x120>
			if ( !AT91F_UDP_IsConfigured(pCdc) ) return length;
		pUdp->UDP_CSR[AT91C_EP_IN] &= ~(AT91C_UDP_TXCOMP);
  100950:	e51b300c 	ldr	r3, [fp, #-12]
  100954:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  100958:	e3c32001 	bic	r2, r3, #1
  10095c:	e51b300c 	ldr	r3, [fp, #-12]
  100960:	e5832038 	str	r2, [r3, #56]	; 0x38
		while (pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP);
  100964:	e1a00000 	nop			; (mov r0, r0)
  100968:	e51b300c 	ldr	r3, [fp, #-12]
  10096c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  100970:	e2033001 	and	r3, r3, #1
  100974:	e20330ff 	and	r3, r3, #255	; 0xff
  100978:	e3530000 	cmp	r3, #0
  10097c:	1afffff9 	bne	100968 <AT91F_UDP_Write+0x168>
		pUdp->UDP_CSR[AT91C_EP_IN] |= AT91C_UDP_TXPKTRDY;
  100980:	e51b300c 	ldr	r3, [fp, #-12]
  100984:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  100988:	e3832010 	orr	r2, r3, #16
  10098c:	e51b300c 	ldr	r3, [fp, #-12]
  100990:	e5832038 	str	r2, [r3, #56]	; 0x38
	cpt = MIN(length, AT91C_EP_IN_SIZE);
	length -= cpt;
	while (cpt--) pUdp->UDP_FDR[AT91C_EP_IN] = *pData++;
	pUdp->UDP_CSR[AT91C_EP_IN] |= AT91C_UDP_TXPKTRDY;

	while (length) {
  100994:	e51b3018 	ldr	r3, [fp, #-24]
  100998:	e3530000 	cmp	r3, #0
  10099c:	1affffc3 	bne	1008b0 <AT91F_UDP_Write+0xb0>
		pUdp->UDP_CSR[AT91C_EP_IN] &= ~(AT91C_UDP_TXCOMP);
		while (pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP);
		pUdp->UDP_CSR[AT91C_EP_IN] |= AT91C_UDP_TXPKTRDY;
	}
	// Wait for the end of transfer
	while ( !(pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP) )
  1009a0:	ea000006 	b	1009c0 <AT91F_UDP_Write+0x1c0>
		if ( !AT91F_UDP_IsConfigured(pCdc) ) return length;
  1009a4:	e51b0010 	ldr	r0, [fp, #-16]
  1009a8:	ebffff04 	bl	1005c0 <AT91F_UDP_IsConfigured>
  1009ac:	e1a03000 	mov	r3, r0
  1009b0:	e3530000 	cmp	r3, #0
  1009b4:	1a000001 	bne	1009c0 <AT91F_UDP_Write+0x1c0>
  1009b8:	e51b3018 	ldr	r3, [fp, #-24]
  1009bc:	ea000011 	b	100a08 <AT91F_UDP_Write+0x208>
		pUdp->UDP_CSR[AT91C_EP_IN] &= ~(AT91C_UDP_TXCOMP);
		while (pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP);
		pUdp->UDP_CSR[AT91C_EP_IN] |= AT91C_UDP_TXPKTRDY;
	}
	// Wait for the end of transfer
	while ( !(pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP) )
  1009c0:	e51b300c 	ldr	r3, [fp, #-12]
  1009c4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  1009c8:	e2033001 	and	r3, r3, #1
  1009cc:	e3530000 	cmp	r3, #0
  1009d0:	0afffff3 	beq	1009a4 <AT91F_UDP_Write+0x1a4>
		if ( !AT91F_UDP_IsConfigured(pCdc) ) return length;
	pUdp->UDP_CSR[AT91C_EP_IN] &= ~(AT91C_UDP_TXCOMP);
  1009d4:	e51b300c 	ldr	r3, [fp, #-12]
  1009d8:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  1009dc:	e3c32001 	bic	r2, r3, #1
  1009e0:	e51b300c 	ldr	r3, [fp, #-12]
  1009e4:	e5832038 	str	r2, [r3, #56]	; 0x38
	while (pUdp->UDP_CSR[AT91C_EP_IN] & AT91C_UDP_TXCOMP);
  1009e8:	e1a00000 	nop			; (mov r0, r0)
  1009ec:	e51b300c 	ldr	r3, [fp, #-12]
  1009f0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  1009f4:	e2033001 	and	r3, r3, #1
  1009f8:	e20330ff 	and	r3, r3, #255	; 0xff
  1009fc:	e3530000 	cmp	r3, #0
  100a00:	1afffff9 	bne	1009ec <AT91F_UDP_Write+0x1ec>

	return length;
  100a04:	e51b3018 	ldr	r3, [fp, #-24]
}
  100a08:	e1a00003 	mov	r0, r3
  100a0c:	e24bd004 	sub	sp, fp, #4
  100a10:	e8bd4800 	pop	{fp, lr}
  100a14:	e12fff1e 	bx	lr

00100a18 <AT91F_USB_SendData>:
//*----------------------------------------------------------------------------
unsigned int csrTab[100];
unsigned char csrIdx = 0;

static void AT91F_USB_SendData(AT91PS_UDP pUdp, const char *pData, uint length)
{
  100a18:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  100a1c:	e28db000 	add	fp, sp, #0
  100a20:	e24dd01c 	sub	sp, sp, #28
  100a24:	e50b0010 	str	r0, [fp, #-16]
  100a28:	e50b1014 	str	r1, [fp, #-20]
  100a2c:	e50b2018 	str	r2, [fp, #-24]
	uint cpt = 0;
  100a30:	e3a03000 	mov	r3, #0
  100a34:	e50b3008 	str	r3, [fp, #-8]
	AT91_REG csr;

	do {
		cpt = MIN(length, 8);
  100a38:	e51b3018 	ldr	r3, [fp, #-24]
  100a3c:	e3530008 	cmp	r3, #8
  100a40:	23a03008 	movcs	r3, #8
  100a44:	e50b3008 	str	r3, [fp, #-8]
		length -= cpt;
  100a48:	e51b2018 	ldr	r2, [fp, #-24]
  100a4c:	e51b3008 	ldr	r3, [fp, #-8]
  100a50:	e0633002 	rsb	r3, r3, r2
  100a54:	e50b3018 	str	r3, [fp, #-24]

		while (cpt--)
  100a58:	ea000007 	b	100a7c <AT91F_USB_SendData+0x64>
			pUdp->UDP_FDR[0] = *pData++;
  100a5c:	e51b3014 	ldr	r3, [fp, #-20]
  100a60:	e5d33000 	ldrb	r3, [r3]
  100a64:	e1a02003 	mov	r2, r3
  100a68:	e51b3010 	ldr	r3, [fp, #-16]
  100a6c:	e5832050 	str	r2, [r3, #80]	; 0x50
  100a70:	e51b3014 	ldr	r3, [fp, #-20]
  100a74:	e2833001 	add	r3, r3, #1
  100a78:	e50b3014 	str	r3, [fp, #-20]

	do {
		cpt = MIN(length, 8);
		length -= cpt;

		while (cpt--)
  100a7c:	e51b3008 	ldr	r3, [fp, #-8]
  100a80:	e3530000 	cmp	r3, #0
  100a84:	03a03000 	moveq	r3, #0
  100a88:	13a03001 	movne	r3, #1
  100a8c:	e20330ff 	and	r3, r3, #255	; 0xff
  100a90:	e51b2008 	ldr	r2, [fp, #-8]
  100a94:	e2422001 	sub	r2, r2, #1
  100a98:	e50b2008 	str	r2, [fp, #-8]
  100a9c:	e3530000 	cmp	r3, #0
  100aa0:	1affffed 	bne	100a5c <AT91F_USB_SendData+0x44>
			pUdp->UDP_FDR[0] = *pData++;

		if (pUdp->UDP_CSR[0] & AT91C_UDP_TXCOMP) {
  100aa4:	e51b3010 	ldr	r3, [fp, #-16]
  100aa8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100aac:	e2033001 	and	r3, r3, #1
  100ab0:	e20330ff 	and	r3, r3, #255	; 0xff
  100ab4:	e3530000 	cmp	r3, #0
  100ab8:	0a00000b 	beq	100aec <AT91F_USB_SendData+0xd4>
			pUdp->UDP_CSR[0] &= ~(AT91C_UDP_TXCOMP);
  100abc:	e51b3010 	ldr	r3, [fp, #-16]
  100ac0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100ac4:	e3c32001 	bic	r2, r3, #1
  100ac8:	e51b3010 	ldr	r3, [fp, #-16]
  100acc:	e5832030 	str	r2, [r3, #48]	; 0x30
			while (pUdp->UDP_CSR[0] & AT91C_UDP_TXCOMP);
  100ad0:	e1a00000 	nop			; (mov r0, r0)
  100ad4:	e51b3010 	ldr	r3, [fp, #-16]
  100ad8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100adc:	e2033001 	and	r3, r3, #1
  100ae0:	e20330ff 	and	r3, r3, #255	; 0xff
  100ae4:	e3530000 	cmp	r3, #0
  100ae8:	1afffff9 	bne	100ad4 <AT91F_USB_SendData+0xbc>
		}

		pUdp->UDP_CSR[0] |= AT91C_UDP_TXPKTRDY;
  100aec:	e51b3010 	ldr	r3, [fp, #-16]
  100af0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100af4:	e3832010 	orr	r2, r3, #16
  100af8:	e51b3010 	ldr	r3, [fp, #-16]
  100afc:	e5832030 	str	r2, [r3, #48]	; 0x30
		do {
			csr = pUdp->UDP_CSR[0];
  100b00:	e51b3010 	ldr	r3, [fp, #-16]
  100b04:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100b08:	e50b300c 	str	r3, [fp, #-12]

			// Data IN stage has been stopped by a status OUT
			if (csr & AT91C_UDP_RX_DATA_BK0) {
  100b0c:	e51b300c 	ldr	r3, [fp, #-12]
  100b10:	e2033002 	and	r3, r3, #2
  100b14:	e3530000 	cmp	r3, #0
  100b18:	0a000005 	beq	100b34 <AT91F_USB_SendData+0x11c>
				pUdp->UDP_CSR[0] &= ~(AT91C_UDP_RX_DATA_BK0);
  100b1c:	e51b3010 	ldr	r3, [fp, #-16]
  100b20:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100b24:	e3c32002 	bic	r2, r3, #2
  100b28:	e51b3010 	ldr	r3, [fp, #-16]
  100b2c:	e5832030 	str	r2, [r3, #48]	; 0x30
				return;
  100b30:	ea000018 	b	100b98 <AT91F_USB_SendData+0x180>
			}
		} while ( !(csr & AT91C_UDP_TXCOMP) );
  100b34:	e51b300c 	ldr	r3, [fp, #-12]
  100b38:	e2033001 	and	r3, r3, #1
  100b3c:	e3530000 	cmp	r3, #0
  100b40:	0affffee 	beq	100b00 <AT91F_USB_SendData+0xe8>

	} while (length);
  100b44:	e51b3018 	ldr	r3, [fp, #-24]
  100b48:	e3530000 	cmp	r3, #0
  100b4c:	1affffb9 	bne	100a38 <AT91F_USB_SendData+0x20>

	if (pUdp->UDP_CSR[0] & AT91C_UDP_TXCOMP) {
  100b50:	e51b3010 	ldr	r3, [fp, #-16]
  100b54:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100b58:	e2033001 	and	r3, r3, #1
  100b5c:	e20330ff 	and	r3, r3, #255	; 0xff
  100b60:	e3530000 	cmp	r3, #0
  100b64:	0a00000b 	beq	100b98 <AT91F_USB_SendData+0x180>
		pUdp->UDP_CSR[0] &= ~(AT91C_UDP_TXCOMP);
  100b68:	e51b3010 	ldr	r3, [fp, #-16]
  100b6c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100b70:	e3c32001 	bic	r2, r3, #1
  100b74:	e51b3010 	ldr	r3, [fp, #-16]
  100b78:	e5832030 	str	r2, [r3, #48]	; 0x30
		while (pUdp->UDP_CSR[0] & AT91C_UDP_TXCOMP);
  100b7c:	e1a00000 	nop			; (mov r0, r0)
  100b80:	e51b3010 	ldr	r3, [fp, #-16]
  100b84:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100b88:	e2033001 	and	r3, r3, #1
  100b8c:	e20330ff 	and	r3, r3, #255	; 0xff
  100b90:	e3530000 	cmp	r3, #0
  100b94:	1afffff9 	bne	100b80 <AT91F_USB_SendData+0x168>
	}
}
  100b98:	e28bd000 	add	sp, fp, #0
  100b9c:	e8bd0800 	pop	{fp}
  100ba0:	e12fff1e 	bx	lr

00100ba4 <AT91F_USB_SendZlp>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_USB_SendZlp
//* \brief Send zero length packet through the control endpoint
//*----------------------------------------------------------------------------
void AT91F_USB_SendZlp(AT91PS_UDP pUdp)
{
  100ba4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  100ba8:	e28db000 	add	fp, sp, #0
  100bac:	e24dd00c 	sub	sp, sp, #12
  100bb0:	e50b0008 	str	r0, [fp, #-8]
	pUdp->UDP_CSR[0] |= AT91C_UDP_TXPKTRDY;
  100bb4:	e51b3008 	ldr	r3, [fp, #-8]
  100bb8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100bbc:	e3832010 	orr	r2, r3, #16
  100bc0:	e51b3008 	ldr	r3, [fp, #-8]
  100bc4:	e5832030 	str	r2, [r3, #48]	; 0x30
	while ( !(pUdp->UDP_CSR[0] & AT91C_UDP_TXCOMP) );
  100bc8:	e1a00000 	nop			; (mov r0, r0)
  100bcc:	e51b3008 	ldr	r3, [fp, #-8]
  100bd0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100bd4:	e2033001 	and	r3, r3, #1
  100bd8:	e3530000 	cmp	r3, #0
  100bdc:	0afffffa 	beq	100bcc <AT91F_USB_SendZlp+0x28>
	pUdp->UDP_CSR[0] &= ~(AT91C_UDP_TXCOMP);
  100be0:	e51b3008 	ldr	r3, [fp, #-8]
  100be4:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100be8:	e3c32001 	bic	r2, r3, #1
  100bec:	e51b3008 	ldr	r3, [fp, #-8]
  100bf0:	e5832030 	str	r2, [r3, #48]	; 0x30
	while (pUdp->UDP_CSR[0] & AT91C_UDP_TXCOMP);
  100bf4:	e1a00000 	nop			; (mov r0, r0)
  100bf8:	e51b3008 	ldr	r3, [fp, #-8]
  100bfc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100c00:	e2033001 	and	r3, r3, #1
  100c04:	e20330ff 	and	r3, r3, #255	; 0xff
  100c08:	e3530000 	cmp	r3, #0
  100c0c:	1afffff9 	bne	100bf8 <AT91F_USB_SendZlp+0x54>
}
  100c10:	e28bd000 	add	sp, fp, #0
  100c14:	e8bd0800 	pop	{fp}
  100c18:	e12fff1e 	bx	lr

00100c1c <AT91F_USB_SendStall>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_USB_SendStall
//* \brief Stall the control endpoint
//*----------------------------------------------------------------------------
void AT91F_USB_SendStall(AT91PS_UDP pUdp)
{
  100c1c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  100c20:	e28db000 	add	fp, sp, #0
  100c24:	e24dd00c 	sub	sp, sp, #12
  100c28:	e50b0008 	str	r0, [fp, #-8]
	pUdp->UDP_CSR[0] |= AT91C_UDP_FORCESTALL;
  100c2c:	e51b3008 	ldr	r3, [fp, #-8]
  100c30:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100c34:	e3832020 	orr	r2, r3, #32
  100c38:	e51b3008 	ldr	r3, [fp, #-8]
  100c3c:	e5832030 	str	r2, [r3, #48]	; 0x30
	while ( !(pUdp->UDP_CSR[0] & AT91C_UDP_ISOERROR) );
  100c40:	e1a00000 	nop			; (mov r0, r0)
  100c44:	e51b3008 	ldr	r3, [fp, #-8]
  100c48:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100c4c:	e2033008 	and	r3, r3, #8
  100c50:	e3530000 	cmp	r3, #0
  100c54:	0afffffa 	beq	100c44 <AT91F_USB_SendStall+0x28>
	pUdp->UDP_CSR[0] &= ~(AT91C_UDP_FORCESTALL | AT91C_UDP_ISOERROR);
  100c58:	e51b3008 	ldr	r3, [fp, #-8]
  100c5c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100c60:	e3c32028 	bic	r2, r3, #40	; 0x28
  100c64:	e51b3008 	ldr	r3, [fp, #-8]
  100c68:	e5832030 	str	r2, [r3, #48]	; 0x30
	while (pUdp->UDP_CSR[0] & (AT91C_UDP_FORCESTALL | AT91C_UDP_ISOERROR));
  100c6c:	e1a00000 	nop			; (mov r0, r0)
  100c70:	e51b3008 	ldr	r3, [fp, #-8]
  100c74:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100c78:	e2033028 	and	r3, r3, #40	; 0x28
  100c7c:	e3530000 	cmp	r3, #0
  100c80:	1afffffa 	bne	100c70 <AT91F_USB_SendStall+0x54>
}
  100c84:	e28bd000 	add	sp, fp, #0
  100c88:	e8bd0800 	pop	{fp}
  100c8c:	e12fff1e 	bx	lr

00100c90 <AT91F_CDC_Enumerate>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_CDC_Enumerate
//* \brief This function is a callback invoked when a SETUP packet is received
//*----------------------------------------------------------------------------
static void AT91F_CDC_Enumerate(AT91PS_CDC pCdc)
{
  100c90:	e92d4800 	push	{fp, lr}
  100c94:	e28db004 	add	fp, sp, #4
  100c98:	e24dd018 	sub	sp, sp, #24
  100c9c:	e50b0018 	str	r0, [fp, #-24]
	AT91PS_UDP pUDP = pCdc->pUdp;
  100ca0:	e51b3018 	ldr	r3, [fp, #-24]
  100ca4:	e5933000 	ldr	r3, [r3]
  100ca8:	e50b3008 	str	r3, [fp, #-8]
	uchar bmRequestType, bRequest;
	ushort wValue, wIndex, wLength, wStatus;


	if ( !(pUDP->UDP_CSR[0] & AT91C_UDP_RXSETUP) )
  100cac:	e51b3008 	ldr	r3, [fp, #-8]
  100cb0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100cb4:	e2033004 	and	r3, r3, #4
  100cb8:	e3530000 	cmp	r3, #0
  100cbc:	0a0001ac 	beq	101374 <AT91F_CDC_Enumerate+0x6e4>
		return;

	bmRequestType = pUDP->UDP_FDR[0];
  100cc0:	e51b3008 	ldr	r3, [fp, #-8]
  100cc4:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100cc8:	e54b3009 	strb	r3, [fp, #-9]
	bRequest      = pUDP->UDP_FDR[0];
  100ccc:	e51b3008 	ldr	r3, [fp, #-8]
  100cd0:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100cd4:	e54b300a 	strb	r3, [fp, #-10]
	wValue        = (pUDP->UDP_FDR[0] & 0xFF);
  100cd8:	e51b3008 	ldr	r3, [fp, #-8]
  100cdc:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100ce0:	e1a03803 	lsl	r3, r3, #16
  100ce4:	e1a03823 	lsr	r3, r3, #16
  100ce8:	e20330ff 	and	r3, r3, #255	; 0xff
  100cec:	e14b30bc 	strh	r3, [fp, #-12]
	wValue       |= (pUDP->UDP_FDR[0] << 8);
  100cf0:	e51b3008 	ldr	r3, [fp, #-8]
  100cf4:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100cf8:	e1a03803 	lsl	r3, r3, #16
  100cfc:	e1a03823 	lsr	r3, r3, #16
  100d00:	e1a03403 	lsl	r3, r3, #8
  100d04:	e1a03803 	lsl	r3, r3, #16
  100d08:	e1a02823 	lsr	r2, r3, #16
  100d0c:	e15b30bc 	ldrh	r3, [fp, #-12]
  100d10:	e1823003 	orr	r3, r2, r3
  100d14:	e14b30bc 	strh	r3, [fp, #-12]
	wIndex        = (pUDP->UDP_FDR[0] & 0xFF);
  100d18:	e51b3008 	ldr	r3, [fp, #-8]
  100d1c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100d20:	e1a03803 	lsl	r3, r3, #16
  100d24:	e1a03823 	lsr	r3, r3, #16
  100d28:	e20330ff 	and	r3, r3, #255	; 0xff
  100d2c:	e14b30be 	strh	r3, [fp, #-14]
	wIndex       |= (pUDP->UDP_FDR[0] << 8);
  100d30:	e51b3008 	ldr	r3, [fp, #-8]
  100d34:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100d38:	e1a03803 	lsl	r3, r3, #16
  100d3c:	e1a03823 	lsr	r3, r3, #16
  100d40:	e1a03403 	lsl	r3, r3, #8
  100d44:	e1a03803 	lsl	r3, r3, #16
  100d48:	e1a02823 	lsr	r2, r3, #16
  100d4c:	e15b30be 	ldrh	r3, [fp, #-14]
  100d50:	e1823003 	orr	r3, r2, r3
  100d54:	e14b30be 	strh	r3, [fp, #-14]
	wLength       = (pUDP->UDP_FDR[0] & 0xFF);
  100d58:	e51b3008 	ldr	r3, [fp, #-8]
  100d5c:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100d60:	e1a03803 	lsl	r3, r3, #16
  100d64:	e1a03823 	lsr	r3, r3, #16
  100d68:	e20330ff 	and	r3, r3, #255	; 0xff
  100d6c:	e14b31b0 	strh	r3, [fp, #-16]
	wLength      |= (pUDP->UDP_FDR[0] << 8);
  100d70:	e51b3008 	ldr	r3, [fp, #-8]
  100d74:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  100d78:	e1a03803 	lsl	r3, r3, #16
  100d7c:	e1a03823 	lsr	r3, r3, #16
  100d80:	e1a03403 	lsl	r3, r3, #8
  100d84:	e1a03803 	lsl	r3, r3, #16
  100d88:	e1a02823 	lsr	r2, r3, #16
  100d8c:	e15b31b0 	ldrh	r3, [fp, #-16]
  100d90:	e1823003 	orr	r3, r2, r3
  100d94:	e14b31b0 	strh	r3, [fp, #-16]

	if (bmRequestType & 0x80) {
  100d98:	e55b3009 	ldrb	r3, [fp, #-9]
  100d9c:	e1a03c03 	lsl	r3, r3, #24
  100da0:	e1a03c43 	asr	r3, r3, #24
  100da4:	e3530000 	cmp	r3, #0
  100da8:	aa00000a 	bge	100dd8 <AT91F_CDC_Enumerate+0x148>
		pUDP->UDP_CSR[0] |= AT91C_UDP_DIR;
  100dac:	e51b3008 	ldr	r3, [fp, #-8]
  100db0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100db4:	e3832080 	orr	r2, r3, #128	; 0x80
  100db8:	e51b3008 	ldr	r3, [fp, #-8]
  100dbc:	e5832030 	str	r2, [r3, #48]	; 0x30
		while ( !(pUDP->UDP_CSR[0] & AT91C_UDP_DIR) );
  100dc0:	e1a00000 	nop			; (mov r0, r0)
  100dc4:	e51b3008 	ldr	r3, [fp, #-8]
  100dc8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100dcc:	e2033080 	and	r3, r3, #128	; 0x80
  100dd0:	e3530000 	cmp	r3, #0
  100dd4:	0afffffa 	beq	100dc4 <AT91F_CDC_Enumerate+0x134>
	}
	pUDP->UDP_CSR[0] &= ~AT91C_UDP_RXSETUP;
  100dd8:	e51b3008 	ldr	r3, [fp, #-8]
  100ddc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100de0:	e3c32004 	bic	r2, r3, #4
  100de4:	e51b3008 	ldr	r3, [fp, #-8]
  100de8:	e5832030 	str	r2, [r3, #48]	; 0x30
	while ( (pUDP->UDP_CSR[0]  & AT91C_UDP_RXSETUP)  );
  100dec:	e1a00000 	nop			; (mov r0, r0)
  100df0:	e51b3008 	ldr	r3, [fp, #-8]
  100df4:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  100df8:	e2033004 	and	r3, r3, #4
  100dfc:	e3530000 	cmp	r3, #0
  100e00:	1afffffa 	bne	100df0 <AT91F_CDC_Enumerate+0x160>

	// Handle supported standard device request Cf Table 9-3 in USB specification Rev 1.1
	switch ((bRequest << 8) | bmRequestType) {
  100e04:	e55b300a 	ldrb	r3, [fp, #-10]
  100e08:	e1a02403 	lsl	r2, r3, #8
  100e0c:	e55b3009 	ldrb	r3, [fp, #-9]
  100e10:	e1823003 	orr	r3, r2, r3
  100e14:	e3a02c03 	mov	r2, #768	; 0x300
  100e18:	e2822001 	add	r2, r2, #1
  100e1c:	e1530002 	cmp	r3, r2
  100e20:	0a0000e8 	beq	1011c8 <AT91F_CDC_Enumerate+0x538>
  100e24:	e3a02c03 	mov	r2, #768	; 0x300
  100e28:	e2822001 	add	r2, r2, #1
  100e2c:	e1530002 	cmp	r3, r2
  100e30:	ca000015 	bgt	100e8c <AT91F_CDC_Enumerate+0x1fc>
  100e34:	e3530c01 	cmp	r3, #256	; 0x100
  100e38:	0a0000fc 	beq	101230 <AT91F_CDC_Enumerate+0x5a0>
  100e3c:	e3530c01 	cmp	r3, #256	; 0x100
  100e40:	ca000006 	bgt	100e60 <AT91F_CDC_Enumerate+0x1d0>
  100e44:	e3530081 	cmp	r3, #129	; 0x81
  100e48:	0a000097 	beq	1010ac <AT91F_CDC_Enumerate+0x41c>
  100e4c:	e3530082 	cmp	r3, #130	; 0x82
  100e50:	0a00009d 	beq	1010cc <AT91F_CDC_Enumerate+0x43c>
  100e54:	e3530080 	cmp	r3, #128	; 0x80
  100e58:	0a00008b 	beq	10108c <AT91F_CDC_Enumerate+0x3fc>
  100e5c:	ea000140 	b	101364 <AT91F_CDC_Enumerate+0x6d4>
  100e60:	e3a02c01 	mov	r2, #256	; 0x100
  100e64:	e2822002 	add	r2, r2, #2
  100e68:	e1530002 	cmp	r3, r2
  100e6c:	0a0000f5 	beq	101248 <AT91F_CDC_Enumerate+0x5b8>
  100e70:	e3a02c01 	mov	r2, #256	; 0x100
  100e74:	e2822002 	add	r2, r2, #2
  100e78:	e1530002 	cmp	r3, r2
  100e7c:	ba0000ee 	blt	10123c <AT91F_CDC_Enumerate+0x5ac>
  100e80:	e3530c03 	cmp	r3, #768	; 0x300
  100e84:	0a0000cc 	beq	1011bc <AT91F_CDC_Enumerate+0x52c>
  100e88:	ea000135 	b	101364 <AT91F_CDC_Enumerate+0x6d4>
  100e8c:	e3530d22 	cmp	r3, #2176	; 0x880
  100e90:	0a000076 	beq	101070 <AT91F_CDC_Enumerate+0x3e0>
  100e94:	e3530d22 	cmp	r3, #2176	; 0x880
  100e98:	ca000008 	bgt	100ec0 <AT91F_CDC_Enumerate+0x230>
  100e9c:	e3530c05 	cmp	r3, #1280	; 0x500
  100ea0:	0a000039 	beq	100f8c <AT91F_CDC_Enumerate+0x2fc>
  100ea4:	e3530d1a 	cmp	r3, #1664	; 0x680
  100ea8:	0a000018 	beq	100f10 <AT91F_CDC_Enumerate+0x280>
  100eac:	e3a02c03 	mov	r2, #768	; 0x300
  100eb0:	e2822002 	add	r2, r2, #2
  100eb4:	e1530002 	cmp	r3, r2
  100eb8:	0a0000c5 	beq	1011d4 <AT91F_CDC_Enumerate+0x544>
  100ebc:	ea000128 	b	101364 <AT91F_CDC_Enumerate+0x6d4>
  100ec0:	e3a02a02 	mov	r2, #8192	; 0x2000
  100ec4:	e2822021 	add	r2, r2, #33	; 0x21
  100ec8:	e1530002 	cmp	r3, r2
  100ecc:	0a000103 	beq	1012e0 <AT91F_CDC_Enumerate+0x650>
  100ed0:	e3a02a02 	mov	r2, #8192	; 0x2000
  100ed4:	e2822021 	add	r2, r2, #33	; 0x21
  100ed8:	e1530002 	cmp	r3, r2
  100edc:	ca000002 	bgt	100eec <AT91F_CDC_Enumerate+0x25c>
  100ee0:	e3530c09 	cmp	r3, #2304	; 0x900
  100ee4:	0a00003a 	beq	100fd4 <AT91F_CDC_Enumerate+0x344>
  100ee8:	ea00011d 	b	101364 <AT91F_CDC_Enumerate+0x6d4>
  100eec:	e3a02d86 	mov	r2, #8576	; 0x2180
  100ef0:	e2822021 	add	r2, r2, #33	; 0x21
  100ef4:	e1530002 	cmp	r3, r2
  100ef8:	0a000106 	beq	101318 <AT91F_CDC_Enumerate+0x688>
  100efc:	e3a02c22 	mov	r2, #8704	; 0x2200
  100f00:	e2822021 	add	r2, r2, #33	; 0x21
  100f04:	e1530002 	cmp	r3, r2
  100f08:	0a00010e 	beq	101348 <AT91F_CDC_Enumerate+0x6b8>
  100f0c:	ea000114 	b	101364 <AT91F_CDC_Enumerate+0x6d4>
	case STD_GET_DESCRIPTOR:
		if (wValue == 0x100)       // Return Device Descriptor
  100f10:	e15b30bc 	ldrh	r3, [fp, #-12]
  100f14:	e3530c01 	cmp	r3, #256	; 0x100
  100f18:	1a00000a 	bne	100f48 <AT91F_CDC_Enumerate+0x2b8>
			AT91F_USB_SendData(pUDP, devDescriptor, MIN(sizeof(devDescriptor), wLength));
  100f1c:	e15b31b0 	ldrh	r3, [fp, #-16]
  100f20:	e3530012 	cmp	r3, #18
  100f24:	8a000001 	bhi	100f30 <AT91F_CDC_Enumerate+0x2a0>
  100f28:	e15b31b0 	ldrh	r3, [fp, #-16]
  100f2c:	ea000000 	b	100f34 <AT91F_CDC_Enumerate+0x2a4>
  100f30:	e3a03012 	mov	r3, #18
  100f34:	e51b0008 	ldr	r0, [fp, #-8]
  100f38:	e59f1444 	ldr	r1, [pc, #1092]	; 101384 <AT91F_CDC_Enumerate+0x6f4>
  100f3c:	e1a02003 	mov	r2, r3
  100f40:	ebfffeb4 	bl	100a18 <AT91F_USB_SendData>
		else if (wValue == 0x200)  // Return Configuration Descriptor
			AT91F_USB_SendData(pUDP, cfgDescriptor, MIN(sizeof(cfgDescriptor), wLength));
		else
			AT91F_USB_SendStall(pUDP);
		break;
  100f44:	ea00010b 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	// Handle supported standard device request Cf Table 9-3 in USB specification Rev 1.1
	switch ((bRequest << 8) | bmRequestType) {
	case STD_GET_DESCRIPTOR:
		if (wValue == 0x100)       // Return Device Descriptor
			AT91F_USB_SendData(pUDP, devDescriptor, MIN(sizeof(devDescriptor), wLength));
		else if (wValue == 0x200)  // Return Configuration Descriptor
  100f48:	e15b30bc 	ldrh	r3, [fp, #-12]
  100f4c:	e3530c02 	cmp	r3, #512	; 0x200
  100f50:	1a00000a 	bne	100f80 <AT91F_CDC_Enumerate+0x2f0>
			AT91F_USB_SendData(pUDP, cfgDescriptor, MIN(sizeof(cfgDescriptor), wLength));
  100f54:	e15b31b0 	ldrh	r3, [fp, #-16]
  100f58:	e3530043 	cmp	r3, #67	; 0x43
  100f5c:	8a000001 	bhi	100f68 <AT91F_CDC_Enumerate+0x2d8>
  100f60:	e15b31b0 	ldrh	r3, [fp, #-16]
  100f64:	ea000000 	b	100f6c <AT91F_CDC_Enumerate+0x2dc>
  100f68:	e3a03043 	mov	r3, #67	; 0x43
  100f6c:	e51b0008 	ldr	r0, [fp, #-8]
  100f70:	e59f1410 	ldr	r1, [pc, #1040]	; 101388 <AT91F_CDC_Enumerate+0x6f8>
  100f74:	e1a02003 	mov	r2, r3
  100f78:	ebfffea6 	bl	100a18 <AT91F_USB_SendData>
		else
			AT91F_USB_SendStall(pUDP);
		break;
  100f7c:	ea0000fd 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
		if (wValue == 0x100)       // Return Device Descriptor
			AT91F_USB_SendData(pUDP, devDescriptor, MIN(sizeof(devDescriptor), wLength));
		else if (wValue == 0x200)  // Return Configuration Descriptor
			AT91F_USB_SendData(pUDP, cfgDescriptor, MIN(sizeof(cfgDescriptor), wLength));
		else
			AT91F_USB_SendStall(pUDP);
  100f80:	e51b0008 	ldr	r0, [fp, #-8]
  100f84:	ebffff24 	bl	100c1c <AT91F_USB_SendStall>
		break;
  100f88:	ea0000fa 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_SET_ADDRESS:
		AT91F_USB_SendZlp(pUDP);
  100f8c:	e51b0008 	ldr	r0, [fp, #-8]
  100f90:	ebffff03 	bl	100ba4 <AT91F_USB_SendZlp>
		pUDP->UDP_FADDR = (AT91C_UDP_FEN | wValue);
  100f94:	e15b30bc 	ldrh	r3, [fp, #-12]
  100f98:	e3833c01 	orr	r3, r3, #256	; 0x100
  100f9c:	e1a03803 	lsl	r3, r3, #16
  100fa0:	e1a03823 	lsr	r3, r3, #16
  100fa4:	e1a02003 	mov	r2, r3
  100fa8:	e51b3008 	ldr	r3, [fp, #-8]
  100fac:	e5832008 	str	r2, [r3, #8]
		pUDP->UDP_GLBSTATE  = (wValue) ? AT91C_UDP_FADDEN : 0;
  100fb0:	e15b30bc 	ldrh	r3, [fp, #-12]
  100fb4:	e3530000 	cmp	r3, #0
  100fb8:	0a000001 	beq	100fc4 <AT91F_CDC_Enumerate+0x334>
  100fbc:	e3a03001 	mov	r3, #1
  100fc0:	ea000000 	b	100fc8 <AT91F_CDC_Enumerate+0x338>
  100fc4:	e3a03000 	mov	r3, #0
  100fc8:	e51b2008 	ldr	r2, [fp, #-8]
  100fcc:	e5823004 	str	r3, [r2, #4]
		break;
  100fd0:	ea0000e8 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_SET_CONFIGURATION:
		pCdc->currentConfiguration = wValue;
  100fd4:	e15b30bc 	ldrh	r3, [fp, #-12]
  100fd8:	e20320ff 	and	r2, r3, #255	; 0xff
  100fdc:	e51b3018 	ldr	r3, [fp, #-24]
  100fe0:	e5c32004 	strb	r2, [r3, #4]
		AT91F_USB_SendZlp(pUDP);
  100fe4:	e51b0008 	ldr	r0, [fp, #-8]
  100fe8:	ebfffeed 	bl	100ba4 <AT91F_USB_SendZlp>
		pUDP->UDP_GLBSTATE  = (wValue) ? AT91C_UDP_CONFG : AT91C_UDP_FADDEN;
  100fec:	e15b30bc 	ldrh	r3, [fp, #-12]
  100ff0:	e3530000 	cmp	r3, #0
  100ff4:	0a000001 	beq	101000 <AT91F_CDC_Enumerate+0x370>
  100ff8:	e3a03002 	mov	r3, #2
  100ffc:	ea000000 	b	101004 <AT91F_CDC_Enumerate+0x374>
  101000:	e3a03001 	mov	r3, #1
  101004:	e51b2008 	ldr	r2, [fp, #-8]
  101008:	e5823004 	str	r3, [r2, #4]
		pUDP->UDP_CSR[1] = (wValue) ? (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_BULK_OUT) : 0;
  10100c:	e15b30bc 	ldrh	r3, [fp, #-12]
  101010:	e3530000 	cmp	r3, #0
  101014:	0a000001 	beq	101020 <AT91F_CDC_Enumerate+0x390>
  101018:	e3a03c82 	mov	r3, #33280	; 0x8200
  10101c:	ea000000 	b	101024 <AT91F_CDC_Enumerate+0x394>
  101020:	e3a03000 	mov	r3, #0
  101024:	e51b2008 	ldr	r2, [fp, #-8]
  101028:	e5823034 	str	r3, [r2, #52]	; 0x34
		pUDP->UDP_CSR[2] = (wValue) ? (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_BULK_IN)  : 0;
  10102c:	e15b30bc 	ldrh	r3, [fp, #-12]
  101030:	e3530000 	cmp	r3, #0
  101034:	0a000001 	beq	101040 <AT91F_CDC_Enumerate+0x3b0>
  101038:	e3a03c86 	mov	r3, #34304	; 0x8600
  10103c:	ea000000 	b	101044 <AT91F_CDC_Enumerate+0x3b4>
  101040:	e3a03000 	mov	r3, #0
  101044:	e51b2008 	ldr	r2, [fp, #-8]
  101048:	e5823038 	str	r3, [r2, #56]	; 0x38
		pUDP->UDP_CSR[3] = (wValue) ? (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_INT_IN)   : 0;
  10104c:	e15b30bc 	ldrh	r3, [fp, #-12]
  101050:	e3530000 	cmp	r3, #0
  101054:	0a000001 	beq	101060 <AT91F_CDC_Enumerate+0x3d0>
  101058:	e3a03c87 	mov	r3, #34560	; 0x8700
  10105c:	ea000000 	b	101064 <AT91F_CDC_Enumerate+0x3d4>
  101060:	e3a03000 	mov	r3, #0
  101064:	e51b2008 	ldr	r2, [fp, #-8]
  101068:	e582303c 	str	r3, [r2, #60]	; 0x3c
		break;
  10106c:	ea0000c1 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_GET_CONFIGURATION:
		AT91F_USB_SendData(pUDP, (char *) &(pCdc->currentConfiguration), sizeof(pCdc->currentConfiguration));
  101070:	e51b3018 	ldr	r3, [fp, #-24]
  101074:	e2833004 	add	r3, r3, #4
  101078:	e51b0008 	ldr	r0, [fp, #-8]
  10107c:	e1a01003 	mov	r1, r3
  101080:	e3a02001 	mov	r2, #1
  101084:	ebfffe63 	bl	100a18 <AT91F_USB_SendData>
		break;
  101088:	ea0000ba 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_GET_STATUS_ZERO:
		wStatus = 0;
  10108c:	e3a03000 	mov	r3, #0
  101090:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
		AT91F_USB_SendData(pUDP, (char *) &wStatus, sizeof(wStatus));
  101094:	e24b3012 	sub	r3, fp, #18
  101098:	e51b0008 	ldr	r0, [fp, #-8]
  10109c:	e1a01003 	mov	r1, r3
  1010a0:	e3a02002 	mov	r2, #2
  1010a4:	ebfffe5b 	bl	100a18 <AT91F_USB_SendData>
		break;
  1010a8:	ea0000b2 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_GET_STATUS_INTERFACE:
		wStatus = 0;
  1010ac:	e3a03000 	mov	r3, #0
  1010b0:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
		AT91F_USB_SendData(pUDP, (char *) &wStatus, sizeof(wStatus));
  1010b4:	e24b3012 	sub	r3, fp, #18
  1010b8:	e51b0008 	ldr	r0, [fp, #-8]
  1010bc:	e1a01003 	mov	r1, r3
  1010c0:	e3a02002 	mov	r2, #2
  1010c4:	ebfffe53 	bl	100a18 <AT91F_USB_SendData>
		break;
  1010c8:	ea0000aa 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_GET_STATUS_ENDPOINT:
		wStatus = 0;
  1010cc:	e3a03000 	mov	r3, #0
  1010d0:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
		wIndex &= 0x0F;
  1010d4:	e15b30be 	ldrh	r3, [fp, #-14]
  1010d8:	e203300f 	and	r3, r3, #15
  1010dc:	e14b30be 	strh	r3, [fp, #-14]
		if ((pUDP->UDP_GLBSTATE & AT91C_UDP_CONFG) && (wIndex <= 3)) {
  1010e0:	e51b3008 	ldr	r3, [fp, #-8]
  1010e4:	e5933004 	ldr	r3, [r3, #4]
  1010e8:	e2033002 	and	r3, r3, #2
  1010ec:	e3530000 	cmp	r3, #0
  1010f0:	0a000013 	beq	101144 <AT91F_CDC_Enumerate+0x4b4>
  1010f4:	e15b30be 	ldrh	r3, [fp, #-14]
  1010f8:	e3530003 	cmp	r3, #3
  1010fc:	8a000010 	bhi	101144 <AT91F_CDC_Enumerate+0x4b4>
			wStatus = (pUDP->UDP_CSR[wIndex] & AT91C_UDP_EPEDS) ? 0 : 1;
  101100:	e15b20be 	ldrh	r2, [fp, #-14]
  101104:	e51b3008 	ldr	r3, [fp, #-8]
  101108:	e282200c 	add	r2, r2, #12
  10110c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  101110:	e2033902 	and	r3, r3, #32768	; 0x8000
  101114:	e3530000 	cmp	r3, #0
  101118:	13a03000 	movne	r3, #0
  10111c:	03a03001 	moveq	r3, #1
  101120:	e1a03803 	lsl	r3, r3, #16
  101124:	e1a03823 	lsr	r3, r3, #16
  101128:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
			AT91F_USB_SendData(pUDP, (char *) &wStatus, sizeof(wStatus));
  10112c:	e24b3012 	sub	r3, fp, #18
  101130:	e51b0008 	ldr	r0, [fp, #-8]
  101134:	e1a01003 	mov	r1, r3
  101138:	e3a02002 	mov	r2, #2
  10113c:	ebfffe35 	bl	100a18 <AT91F_USB_SendData>
  101140:	ea00001c 	b	1011b8 <AT91F_CDC_Enumerate+0x528>
		}
		else if ((pUDP->UDP_GLBSTATE & AT91C_UDP_FADDEN) && (wIndex == 0)) {
  101144:	e51b3008 	ldr	r3, [fp, #-8]
  101148:	e5933004 	ldr	r3, [r3, #4]
  10114c:	e2033001 	and	r3, r3, #1
  101150:	e20330ff 	and	r3, r3, #255	; 0xff
  101154:	e3530000 	cmp	r3, #0
  101158:	0a000013 	beq	1011ac <AT91F_CDC_Enumerate+0x51c>
  10115c:	e15b30be 	ldrh	r3, [fp, #-14]
  101160:	e3530000 	cmp	r3, #0
  101164:	1a000010 	bne	1011ac <AT91F_CDC_Enumerate+0x51c>
			wStatus = (pUDP->UDP_CSR[wIndex] & AT91C_UDP_EPEDS) ? 0 : 1;
  101168:	e15b20be 	ldrh	r2, [fp, #-14]
  10116c:	e51b3008 	ldr	r3, [fp, #-8]
  101170:	e282200c 	add	r2, r2, #12
  101174:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  101178:	e2033902 	and	r3, r3, #32768	; 0x8000
  10117c:	e3530000 	cmp	r3, #0
  101180:	13a03000 	movne	r3, #0
  101184:	03a03001 	moveq	r3, #1
  101188:	e1a03803 	lsl	r3, r3, #16
  10118c:	e1a03823 	lsr	r3, r3, #16
  101190:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
			AT91F_USB_SendData(pUDP, (char *) &wStatus, sizeof(wStatus));
  101194:	e24b3012 	sub	r3, fp, #18
  101198:	e51b0008 	ldr	r0, [fp, #-8]
  10119c:	e1a01003 	mov	r1, r3
  1011a0:	e3a02002 	mov	r2, #2
  1011a4:	ebfffe1b 	bl	100a18 <AT91F_USB_SendData>
  1011a8:	ea000002 	b	1011b8 <AT91F_CDC_Enumerate+0x528>
		}
		else
			AT91F_USB_SendStall(pUDP);
  1011ac:	e51b0008 	ldr	r0, [fp, #-8]
  1011b0:	ebfffe99 	bl	100c1c <AT91F_USB_SendStall>
		break;
  1011b4:	ea00006f 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
  1011b8:	ea00006e 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_SET_FEATURE_ZERO:
		AT91F_USB_SendStall(pUDP);
  1011bc:	e51b0008 	ldr	r0, [fp, #-8]
  1011c0:	ebfffe95 	bl	100c1c <AT91F_USB_SendStall>
	    break;
  1011c4:	ea00006b 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_SET_FEATURE_INTERFACE:
		AT91F_USB_SendZlp(pUDP);
  1011c8:	e51b0008 	ldr	r0, [fp, #-8]
  1011cc:	ebfffe74 	bl	100ba4 <AT91F_USB_SendZlp>
		break;
  1011d0:	ea000068 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_SET_FEATURE_ENDPOINT:
		wIndex &= 0x0F;
  1011d4:	e15b30be 	ldrh	r3, [fp, #-14]
  1011d8:	e203300f 	and	r3, r3, #15
  1011dc:	e14b30be 	strh	r3, [fp, #-14]
		if ((wValue == 0) && wIndex && (wIndex <= 3)) {
  1011e0:	e15b30bc 	ldrh	r3, [fp, #-12]
  1011e4:	e3530000 	cmp	r3, #0
  1011e8:	1a00000d 	bne	101224 <AT91F_CDC_Enumerate+0x594>
  1011ec:	e15b30be 	ldrh	r3, [fp, #-14]
  1011f0:	e3530000 	cmp	r3, #0
  1011f4:	0a00000a 	beq	101224 <AT91F_CDC_Enumerate+0x594>
  1011f8:	e15b30be 	ldrh	r3, [fp, #-14]
  1011fc:	e3530003 	cmp	r3, #3
  101200:	8a000007 	bhi	101224 <AT91F_CDC_Enumerate+0x594>
			pUDP->UDP_CSR[wIndex] = 0;
  101204:	e15b20be 	ldrh	r2, [fp, #-14]
  101208:	e51b3008 	ldr	r3, [fp, #-8]
  10120c:	e282200c 	add	r2, r2, #12
  101210:	e3a01000 	mov	r1, #0
  101214:	e7831102 	str	r1, [r3, r2, lsl #2]
			AT91F_USB_SendZlp(pUDP);
  101218:	e51b0008 	ldr	r0, [fp, #-8]
  10121c:	ebfffe60 	bl	100ba4 <AT91F_USB_SendZlp>
		}
		else
			AT91F_USB_SendStall(pUDP);
		break;
  101220:	ea000054 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
		if ((wValue == 0) && wIndex && (wIndex <= 3)) {
			pUDP->UDP_CSR[wIndex] = 0;
			AT91F_USB_SendZlp(pUDP);
		}
		else
			AT91F_USB_SendStall(pUDP);
  101224:	e51b0008 	ldr	r0, [fp, #-8]
  101228:	ebfffe7b 	bl	100c1c <AT91F_USB_SendStall>
		break;
  10122c:	ea000051 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_CLEAR_FEATURE_ZERO:
		AT91F_USB_SendStall(pUDP);
  101230:	e51b0008 	ldr	r0, [fp, #-8]
  101234:	ebfffe78 	bl	100c1c <AT91F_USB_SendStall>
	    break;
  101238:	ea00004e 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_CLEAR_FEATURE_INTERFACE:
		AT91F_USB_SendZlp(pUDP);
  10123c:	e51b0008 	ldr	r0, [fp, #-8]
  101240:	ebfffe57 	bl	100ba4 <AT91F_USB_SendZlp>
		break;
  101244:	ea00004b 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case STD_CLEAR_FEATURE_ENDPOINT:
		wIndex &= 0x0F;
  101248:	e15b30be 	ldrh	r3, [fp, #-14]
  10124c:	e203300f 	and	r3, r3, #15
  101250:	e14b30be 	strh	r3, [fp, #-14]
		if ((wValue == 0) && wIndex && (wIndex <= 3)) {
  101254:	e15b30bc 	ldrh	r3, [fp, #-12]
  101258:	e3530000 	cmp	r3, #0
  10125c:	1a00001c 	bne	1012d4 <AT91F_CDC_Enumerate+0x644>
  101260:	e15b30be 	ldrh	r3, [fp, #-14]
  101264:	e3530000 	cmp	r3, #0
  101268:	0a000019 	beq	1012d4 <AT91F_CDC_Enumerate+0x644>
  10126c:	e15b30be 	ldrh	r3, [fp, #-14]
  101270:	e3530003 	cmp	r3, #3
  101274:	8a000016 	bhi	1012d4 <AT91F_CDC_Enumerate+0x644>
			if (wIndex == 1)
  101278:	e15b30be 	ldrh	r3, [fp, #-14]
  10127c:	e3530001 	cmp	r3, #1
  101280:	1a000003 	bne	101294 <AT91F_CDC_Enumerate+0x604>
				pUDP->UDP_CSR[1] = (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_BULK_OUT);
  101284:	e51b3008 	ldr	r3, [fp, #-8]
  101288:	e3a02c82 	mov	r2, #33280	; 0x8200
  10128c:	e5832034 	str	r2, [r3, #52]	; 0x34
  101290:	ea00000c 	b	1012c8 <AT91F_CDC_Enumerate+0x638>
			else if (wIndex == 2)
  101294:	e15b30be 	ldrh	r3, [fp, #-14]
  101298:	e3530002 	cmp	r3, #2
  10129c:	1a000003 	bne	1012b0 <AT91F_CDC_Enumerate+0x620>
				pUDP->UDP_CSR[2] = (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_BULK_IN);
  1012a0:	e51b3008 	ldr	r3, [fp, #-8]
  1012a4:	e3a02c86 	mov	r2, #34304	; 0x8600
  1012a8:	e5832038 	str	r2, [r3, #56]	; 0x38
  1012ac:	ea000005 	b	1012c8 <AT91F_CDC_Enumerate+0x638>
			else if (wIndex == 3)
  1012b0:	e15b30be 	ldrh	r3, [fp, #-14]
  1012b4:	e3530003 	cmp	r3, #3
  1012b8:	1a000002 	bne	1012c8 <AT91F_CDC_Enumerate+0x638>
				pUDP->UDP_CSR[3] = (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_ISO_IN);
  1012bc:	e51b3008 	ldr	r3, [fp, #-8]
  1012c0:	e3a02c85 	mov	r2, #34048	; 0x8500
  1012c4:	e583203c 	str	r2, [r3, #60]	; 0x3c
			AT91F_USB_SendZlp(pUDP);
  1012c8:	e51b0008 	ldr	r0, [fp, #-8]
  1012cc:	ebfffe34 	bl	100ba4 <AT91F_USB_SendZlp>
		}
		else
			AT91F_USB_SendStall(pUDP);
		break;
  1012d0:	ea000028 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
			else if (wIndex == 3)
				pUDP->UDP_CSR[3] = (AT91C_UDP_EPEDS | AT91C_UDP_EPTYPE_ISO_IN);
			AT91F_USB_SendZlp(pUDP);
		}
		else
			AT91F_USB_SendStall(pUDP);
  1012d4:	e51b0008 	ldr	r0, [fp, #-8]
  1012d8:	ebfffe4f 	bl	100c1c <AT91F_USB_SendStall>
		break;
  1012dc:	ea000025 	b	101378 <AT91F_CDC_Enumerate+0x6e8>

	// handle CDC class requests
	case SET_LINE_CODING:
		while ( !(pUDP->UDP_CSR[0] & AT91C_UDP_RX_DATA_BK0) );
  1012e0:	e1a00000 	nop			; (mov r0, r0)
  1012e4:	e51b3008 	ldr	r3, [fp, #-8]
  1012e8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  1012ec:	e2033002 	and	r3, r3, #2
  1012f0:	e3530000 	cmp	r3, #0
  1012f4:	0afffffa 	beq	1012e4 <AT91F_CDC_Enumerate+0x654>
		pUDP->UDP_CSR[0] &= ~(AT91C_UDP_RX_DATA_BK0);
  1012f8:	e51b3008 	ldr	r3, [fp, #-8]
  1012fc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  101300:	e3c32002 	bic	r2, r3, #2
  101304:	e51b3008 	ldr	r3, [fp, #-8]
  101308:	e5832030 	str	r2, [r3, #48]	; 0x30
		AT91F_USB_SendZlp(pUDP);
  10130c:	e51b0008 	ldr	r0, [fp, #-8]
  101310:	ebfffe23 	bl	100ba4 <AT91F_USB_SendZlp>
		break;
  101314:	ea000017 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case GET_LINE_CODING:
		AT91F_USB_SendData(pUDP, (char *) &line, MIN(sizeof(line), wLength));
  101318:	e59f206c 	ldr	r2, [pc, #108]	; 10138c <AT91F_CDC_Enumerate+0x6fc>
  10131c:	e15b31b0 	ldrh	r3, [fp, #-16]
  101320:	e3530008 	cmp	r3, #8
  101324:	8a000001 	bhi	101330 <AT91F_CDC_Enumerate+0x6a0>
  101328:	e15b31b0 	ldrh	r3, [fp, #-16]
  10132c:	ea000000 	b	101334 <AT91F_CDC_Enumerate+0x6a4>
  101330:	e3a03008 	mov	r3, #8
  101334:	e51b0008 	ldr	r0, [fp, #-8]
  101338:	e1a01002 	mov	r1, r2
  10133c:	e1a02003 	mov	r2, r3
  101340:	ebfffdb4 	bl	100a18 <AT91F_USB_SendData>
		break;
  101344:	ea00000b 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	case SET_CONTROL_LINE_STATE:
		pCdc->currentConnection = wValue;
  101348:	e15b30bc 	ldrh	r3, [fp, #-12]
  10134c:	e20320ff 	and	r2, r3, #255	; 0xff
  101350:	e51b3018 	ldr	r3, [fp, #-24]
  101354:	e5c32005 	strb	r2, [r3, #5]
		AT91F_USB_SendZlp(pUDP);
  101358:	e51b0008 	ldr	r0, [fp, #-8]
  10135c:	ebfffe10 	bl	100ba4 <AT91F_USB_SendZlp>
		break;
  101360:	ea000004 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	default:
		AT91F_USB_SendStall(pUDP);
  101364:	e51b0008 	ldr	r0, [fp, #-8]
  101368:	ebfffe2b 	bl	100c1c <AT91F_USB_SendStall>
	    break;
  10136c:	e1a00000 	nop			; (mov r0, r0)
  101370:	ea000000 	b	101378 <AT91F_CDC_Enumerate+0x6e8>
	uchar bmRequestType, bRequest;
	ushort wValue, wIndex, wLength, wStatus;


	if ( !(pUDP->UDP_CSR[0] & AT91C_UDP_RXSETUP) )
		return;
  101374:	e1a00000 	nop			; (mov r0, r0)
		break;
	default:
		AT91F_USB_SendStall(pUDP);
	    break;
	}
}
  101378:	e24bd004 	sub	sp, fp, #4
  10137c:	e8bd4800 	pop	{fp, lr}
  101380:	e12fff1e 	bx	lr
  101384:	00101ebc 	.word	0x00101ebc
  101388:	00101ed0 	.word	0x00101ed0
  10138c:	002001c8 	.word	0x002001c8

00101390 <AT91F_AIC_ConfigureIt>:
	AT91PS_AIC pAic,  // \arg pointer to the AIC registers
	unsigned int irq_id,     // \arg interrupt number to initialize
	unsigned int priority,   // \arg priority to give to the interrupt
	unsigned int src_type,   // \arg activation and sense of activation
	void (*newHandler) () ) // \arg address of the interrupt handler
{
  101390:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101394:	e28db000 	add	fp, sp, #0
  101398:	e24dd01c 	sub	sp, sp, #28
  10139c:	e50b0010 	str	r0, [fp, #-16]
  1013a0:	e50b1014 	str	r1, [fp, #-20]
  1013a4:	e50b2018 	str	r2, [fp, #-24]
  1013a8:	e50b301c 	str	r3, [fp, #-28]
	unsigned int oldHandler;
    unsigned int mask ;

    oldHandler = pAic->AIC_SVR[irq_id];
  1013ac:	e51b3010 	ldr	r3, [fp, #-16]
  1013b0:	e51b2014 	ldr	r2, [fp, #-20]
  1013b4:	e2822020 	add	r2, r2, #32
  1013b8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  1013bc:	e50b3008 	str	r3, [fp, #-8]

    mask = 0x1 << irq_id ;
  1013c0:	e51b3014 	ldr	r3, [fp, #-20]
  1013c4:	e3a02001 	mov	r2, #1
  1013c8:	e1a03312 	lsl	r3, r2, r3
  1013cc:	e50b300c 	str	r3, [fp, #-12]
    //* Disable the interrupt on the interrupt controller
    pAic->AIC_IDCR = mask ;
  1013d0:	e51b3010 	ldr	r3, [fp, #-16]
  1013d4:	e51b200c 	ldr	r2, [fp, #-12]
  1013d8:	e5832124 	str	r2, [r3, #292]	; 0x124
    //* Save the interrupt handler routine pointer and the interrupt priority
    pAic->AIC_SVR[irq_id] = (unsigned int) newHandler ;
  1013dc:	e59b1004 	ldr	r1, [fp, #4]
  1013e0:	e51b3010 	ldr	r3, [fp, #-16]
  1013e4:	e51b2014 	ldr	r2, [fp, #-20]
  1013e8:	e2822020 	add	r2, r2, #32
  1013ec:	e7831102 	str	r1, [r3, r2, lsl #2]
    //* Store the Source Mode Register
    pAic->AIC_SMR[irq_id] = src_type | priority  ;
  1013f0:	e51b201c 	ldr	r2, [fp, #-28]
  1013f4:	e51b3018 	ldr	r3, [fp, #-24]
  1013f8:	e1821003 	orr	r1, r2, r3
  1013fc:	e51b3010 	ldr	r3, [fp, #-16]
  101400:	e51b2014 	ldr	r2, [fp, #-20]
  101404:	e7831102 	str	r1, [r3, r2, lsl #2]
    //* Clear the interrupt on the interrupt controller
    pAic->AIC_ICCR = mask ;
  101408:	e51b3010 	ldr	r3, [fp, #-16]
  10140c:	e51b200c 	ldr	r2, [fp, #-12]
  101410:	e5832128 	str	r2, [r3, #296]	; 0x128

	return oldHandler;
  101414:	e51b3008 	ldr	r3, [fp, #-8]
}
  101418:	e1a00003 	mov	r0, r3
  10141c:	e28bd000 	add	sp, fp, #0
  101420:	e8bd0800 	pop	{fp}
  101424:	e12fff1e 	bx	lr

00101428 <AT91F_AIC_EnableIt>:
//* \brief Enable corresponding IT number
//*----------------------------------------------------------------------------
__inline void AT91F_AIC_EnableIt (
	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
	unsigned int irq_id ) // \arg interrupt number to initialize
{
  101428:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10142c:	e28db000 	add	fp, sp, #0
  101430:	e24dd00c 	sub	sp, sp, #12
  101434:	e50b0008 	str	r0, [fp, #-8]
  101438:	e50b100c 	str	r1, [fp, #-12]
    //* Enable the interrupt on the interrupt controller
    pAic->AIC_IECR = 0x1 << irq_id ;
  10143c:	e51b300c 	ldr	r3, [fp, #-12]
  101440:	e3a02001 	mov	r2, #1
  101444:	e1a03312 	lsl	r3, r2, r3
  101448:	e1a02003 	mov	r2, r3
  10144c:	e51b3008 	ldr	r3, [fp, #-8]
  101450:	e5832120 	str	r2, [r3, #288]	; 0x120
}
  101454:	e28bd000 	add	sp, fp, #0
  101458:	e8bd0800 	pop	{fp}
  10145c:	e12fff1e 	bx	lr

00101460 <AT91F_PDC_SetNextRx>:
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_SetNextRx (
	AT91PS_PDC pPDC,     // \arg pointer to a PDC controller
	char *address,       // \arg address to the next bloc to be received
	unsigned int bytes)  // \arg number of bytes to be received
{
  101460:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101464:	e28db000 	add	fp, sp, #0
  101468:	e24dd014 	sub	sp, sp, #20
  10146c:	e50b0008 	str	r0, [fp, #-8]
  101470:	e50b100c 	str	r1, [fp, #-12]
  101474:	e50b2010 	str	r2, [fp, #-16]
	pPDC->PDC_RNPR = (unsigned int) address;
  101478:	e51b200c 	ldr	r2, [fp, #-12]
  10147c:	e51b3008 	ldr	r3, [fp, #-8]
  101480:	e5832010 	str	r2, [r3, #16]
	pPDC->PDC_RNCR = bytes;
  101484:	e51b3008 	ldr	r3, [fp, #-8]
  101488:	e51b2010 	ldr	r2, [fp, #-16]
  10148c:	e5832014 	str	r2, [r3, #20]
}
  101490:	e28bd000 	add	sp, fp, #0
  101494:	e8bd0800 	pop	{fp}
  101498:	e12fff1e 	bx	lr

0010149c <AT91F_PDC_SetNextTx>:
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_SetNextTx (
	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
	char *address,         // \arg address to the next bloc to be transmitted
	unsigned int bytes)    // \arg number of bytes to be transmitted
{
  10149c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1014a0:	e28db000 	add	fp, sp, #0
  1014a4:	e24dd014 	sub	sp, sp, #20
  1014a8:	e50b0008 	str	r0, [fp, #-8]
  1014ac:	e50b100c 	str	r1, [fp, #-12]
  1014b0:	e50b2010 	str	r2, [fp, #-16]
	pPDC->PDC_TNPR = (unsigned int) address;
  1014b4:	e51b200c 	ldr	r2, [fp, #-12]
  1014b8:	e51b3008 	ldr	r3, [fp, #-8]
  1014bc:	e5832018 	str	r2, [r3, #24]
	pPDC->PDC_TNCR = bytes;
  1014c0:	e51b3008 	ldr	r3, [fp, #-8]
  1014c4:	e51b2010 	ldr	r2, [fp, #-16]
  1014c8:	e583201c 	str	r2, [r3, #28]
}
  1014cc:	e28bd000 	add	sp, fp, #0
  1014d0:	e8bd0800 	pop	{fp}
  1014d4:	e12fff1e 	bx	lr

001014d8 <AT91F_PDC_SetRx>:
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_SetRx (
	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
	char *address,         // \arg address to the next bloc to be received
	unsigned int bytes)    // \arg number of bytes to be received
{
  1014d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1014dc:	e28db000 	add	fp, sp, #0
  1014e0:	e24dd014 	sub	sp, sp, #20
  1014e4:	e50b0008 	str	r0, [fp, #-8]
  1014e8:	e50b100c 	str	r1, [fp, #-12]
  1014ec:	e50b2010 	str	r2, [fp, #-16]
	pPDC->PDC_RPR = (unsigned int) address;
  1014f0:	e51b200c 	ldr	r2, [fp, #-12]
  1014f4:	e51b3008 	ldr	r3, [fp, #-8]
  1014f8:	e5832000 	str	r2, [r3]
	pPDC->PDC_RCR = bytes;
  1014fc:	e51b3008 	ldr	r3, [fp, #-8]
  101500:	e51b2010 	ldr	r2, [fp, #-16]
  101504:	e5832004 	str	r2, [r3, #4]
}
  101508:	e28bd000 	add	sp, fp, #0
  10150c:	e8bd0800 	pop	{fp}
  101510:	e12fff1e 	bx	lr

00101514 <AT91F_PDC_SetTx>:
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_SetTx (
	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
	char *address,         // \arg address to the next bloc to be transmitted
	unsigned int bytes)    // \arg number of bytes to be transmitted
{
  101514:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101518:	e28db000 	add	fp, sp, #0
  10151c:	e24dd014 	sub	sp, sp, #20
  101520:	e50b0008 	str	r0, [fp, #-8]
  101524:	e50b100c 	str	r1, [fp, #-12]
  101528:	e50b2010 	str	r2, [fp, #-16]
	pPDC->PDC_TPR = (unsigned int) address;
  10152c:	e51b200c 	ldr	r2, [fp, #-12]
  101530:	e51b3008 	ldr	r3, [fp, #-8]
  101534:	e5832008 	str	r2, [r3, #8]
	pPDC->PDC_TCR = bytes;
  101538:	e51b3008 	ldr	r3, [fp, #-8]
  10153c:	e51b2010 	ldr	r2, [fp, #-16]
  101540:	e583200c 	str	r2, [r3, #12]
}
  101544:	e28bd000 	add	sp, fp, #0
  101548:	e8bd0800 	pop	{fp}
  10154c:	e12fff1e 	bx	lr

00101550 <AT91F_PDC_EnableTx>:
//* \fn    AT91F_PDC_EnableTx
//* \brief Enable transmit
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_EnableTx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
  101550:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101554:	e28db000 	add	fp, sp, #0
  101558:	e24dd00c 	sub	sp, sp, #12
  10155c:	e50b0008 	str	r0, [fp, #-8]
	pPDC->PDC_PTCR = AT91C_PDC_TXTEN;
  101560:	e51b3008 	ldr	r3, [fp, #-8]
  101564:	e3a02c01 	mov	r2, #256	; 0x100
  101568:	e5832020 	str	r2, [r3, #32]
}
  10156c:	e28bd000 	add	sp, fp, #0
  101570:	e8bd0800 	pop	{fp}
  101574:	e12fff1e 	bx	lr

00101578 <AT91F_PDC_EnableRx>:
//* \fn    AT91F_PDC_EnableRx
//* \brief Enable receive
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_EnableRx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
  101578:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10157c:	e28db000 	add	fp, sp, #0
  101580:	e24dd00c 	sub	sp, sp, #12
  101584:	e50b0008 	str	r0, [fp, #-8]
	pPDC->PDC_PTCR = AT91C_PDC_RXTEN;
  101588:	e51b3008 	ldr	r3, [fp, #-8]
  10158c:	e3a02001 	mov	r2, #1
  101590:	e5832020 	str	r2, [r3, #32]
}
  101594:	e28bd000 	add	sp, fp, #0
  101598:	e8bd0800 	pop	{fp}
  10159c:	e12fff1e 	bx	lr

001015a0 <AT91F_PDC_DisableTx>:
//* \fn    AT91F_PDC_DisableTx
//* \brief Disable transmit
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_DisableTx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
  1015a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1015a4:	e28db000 	add	fp, sp, #0
  1015a8:	e24dd00c 	sub	sp, sp, #12
  1015ac:	e50b0008 	str	r0, [fp, #-8]
	pPDC->PDC_PTCR = AT91C_PDC_TXTDIS;
  1015b0:	e51b3008 	ldr	r3, [fp, #-8]
  1015b4:	e3a02c02 	mov	r2, #512	; 0x200
  1015b8:	e5832020 	str	r2, [r3, #32]
}
  1015bc:	e28bd000 	add	sp, fp, #0
  1015c0:	e8bd0800 	pop	{fp}
  1015c4:	e12fff1e 	bx	lr

001015c8 <AT91F_PDC_DisableRx>:
//* \fn    AT91F_PDC_DisableRx
//* \brief Disable receive
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_DisableRx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
  1015c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1015cc:	e28db000 	add	fp, sp, #0
  1015d0:	e24dd00c 	sub	sp, sp, #12
  1015d4:	e50b0008 	str	r0, [fp, #-8]
	pPDC->PDC_PTCR = AT91C_PDC_RXTDIS;
  1015d8:	e51b3008 	ldr	r3, [fp, #-8]
  1015dc:	e3a02002 	mov	r2, #2
  1015e0:	e5832020 	str	r2, [r3, #32]
}
  1015e4:	e28bd000 	add	sp, fp, #0
  1015e8:	e8bd0800 	pop	{fp}
  1015ec:	e12fff1e 	bx	lr

001015f0 <AT91F_PDC_Open>:
//* \fn    AT91F_PDC_Open
//* \brief Open PDC: disable TX and RX reset transfer descriptors, re-enable RX and TX
//*----------------------------------------------------------------------------
__inline void AT91F_PDC_Open (
	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
{
  1015f0:	e92d4800 	push	{fp, lr}
  1015f4:	e28db004 	add	fp, sp, #4
  1015f8:	e24dd008 	sub	sp, sp, #8
  1015fc:	e50b0008 	str	r0, [fp, #-8]
    //* Disable the RX and TX PDC transfer requests
	AT91F_PDC_DisableRx(pPDC);
  101600:	e51b0008 	ldr	r0, [fp, #-8]
  101604:	ebffffef 	bl	1015c8 <AT91F_PDC_DisableRx>
	AT91F_PDC_DisableTx(pPDC);
  101608:	e51b0008 	ldr	r0, [fp, #-8]
  10160c:	ebffffe3 	bl	1015a0 <AT91F_PDC_DisableTx>

	//* Reset all Counter register Next buffer first
	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
  101610:	e51b0008 	ldr	r0, [fp, #-8]
  101614:	e3a01000 	mov	r1, #0
  101618:	e3a02000 	mov	r2, #0
  10161c:	ebffff9e 	bl	10149c <AT91F_PDC_SetNextTx>
	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
  101620:	e51b0008 	ldr	r0, [fp, #-8]
  101624:	e3a01000 	mov	r1, #0
  101628:	e3a02000 	mov	r2, #0
  10162c:	ebffff8b 	bl	101460 <AT91F_PDC_SetNextRx>
	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
  101630:	e51b0008 	ldr	r0, [fp, #-8]
  101634:	e3a01000 	mov	r1, #0
  101638:	e3a02000 	mov	r2, #0
  10163c:	ebffffb4 	bl	101514 <AT91F_PDC_SetTx>
	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
  101640:	e51b0008 	ldr	r0, [fp, #-8]
  101644:	e3a01000 	mov	r1, #0
  101648:	e3a02000 	mov	r2, #0
  10164c:	ebffffa1 	bl	1014d8 <AT91F_PDC_SetRx>

    //* Enable the RX and TX PDC transfer requests
	AT91F_PDC_EnableRx(pPDC);
  101650:	e51b0008 	ldr	r0, [fp, #-8]
  101654:	ebffffc7 	bl	101578 <AT91F_PDC_EnableRx>
	AT91F_PDC_EnableTx(pPDC);
  101658:	e51b0008 	ldr	r0, [fp, #-8]
  10165c:	ebffffbb 	bl	101550 <AT91F_PDC_EnableTx>
}
  101660:	e24bd004 	sub	sp, fp, #4
  101664:	e8bd4800 	pop	{fp, lr}
  101668:	e12fff1e 	bx	lr

0010166c <AT91F_PIO_CfgPeriph>:
__inline void AT91F_PIO_CfgPeriph(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int periphAEnable,  // \arg PERIPH A to enable
	unsigned int periphBEnable)  // \arg PERIPH B to enable

{
  10166c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101670:	e28db000 	add	fp, sp, #0
  101674:	e24dd014 	sub	sp, sp, #20
  101678:	e50b0008 	str	r0, [fp, #-8]
  10167c:	e50b100c 	str	r1, [fp, #-12]
  101680:	e50b2010 	str	r2, [fp, #-16]
	pPio->PIO_ASR = periphAEnable;
  101684:	e51b3008 	ldr	r3, [fp, #-8]
  101688:	e51b200c 	ldr	r2, [fp, #-12]
  10168c:	e5832070 	str	r2, [r3, #112]	; 0x70
	pPio->PIO_BSR = periphBEnable;
  101690:	e51b3008 	ldr	r3, [fp, #-8]
  101694:	e51b2010 	ldr	r2, [fp, #-16]
  101698:	e5832074 	str	r2, [r3, #116]	; 0x74
	pPio->PIO_PDR = (periphAEnable | periphBEnable); // Set in Periph mode
  10169c:	e51b200c 	ldr	r2, [fp, #-12]
  1016a0:	e51b3010 	ldr	r3, [fp, #-16]
  1016a4:	e1822003 	orr	r2, r2, r3
  1016a8:	e51b3008 	ldr	r3, [fp, #-8]
  1016ac:	e5832004 	str	r2, [r3, #4]
}
  1016b0:	e28bd000 	add	sp, fp, #0
  1016b4:	e8bd0800 	pop	{fp}
  1016b8:	e12fff1e 	bx	lr

001016bc <AT91F_PIO_GetInput>:
//* \fn    AT91F_PIO_GetInput
//* \brief Return PIO input value
//*----------------------------------------------------------------------------
__inline unsigned int AT91F_PIO_GetInput( // \return PIO input
	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
  1016bc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1016c0:	e28db000 	add	fp, sp, #0
  1016c4:	e24dd00c 	sub	sp, sp, #12
  1016c8:	e50b0008 	str	r0, [fp, #-8]
	return pPio->PIO_PDSR;
  1016cc:	e51b3008 	ldr	r3, [fp, #-8]
  1016d0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
}
  1016d4:	e1a00003 	mov	r0, r3
  1016d8:	e28bd000 	add	sp, fp, #0
  1016dc:	e8bd0800 	pop	{fp}
  1016e0:	e12fff1e 	bx	lr

001016e4 <AT91F_PIO_SetOutput>:
//* \brief Set to 1 output PIO
//*----------------------------------------------------------------------------
__inline void AT91F_PIO_SetOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be set
{
  1016e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1016e8:	e28db000 	add	fp, sp, #0
  1016ec:	e24dd00c 	sub	sp, sp, #12
  1016f0:	e50b0008 	str	r0, [fp, #-8]
  1016f4:	e50b100c 	str	r1, [fp, #-12]
	pPio->PIO_SODR = flag;
  1016f8:	e51b3008 	ldr	r3, [fp, #-8]
  1016fc:	e51b200c 	ldr	r2, [fp, #-12]
  101700:	e5832030 	str	r2, [r3, #48]	; 0x30
}
  101704:	e28bd000 	add	sp, fp, #0
  101708:	e8bd0800 	pop	{fp}
  10170c:	e12fff1e 	bx	lr

00101710 <AT91F_PIO_ClearOutput>:
//* \brief Set to 0 output PIO
//*----------------------------------------------------------------------------
__inline void AT91F_PIO_ClearOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be cleared
{
  101710:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101714:	e28db000 	add	fp, sp, #0
  101718:	e24dd00c 	sub	sp, sp, #12
  10171c:	e50b0008 	str	r0, [fp, #-8]
  101720:	e50b100c 	str	r1, [fp, #-12]
	pPio->PIO_CODR = flag;
  101724:	e51b3008 	ldr	r3, [fp, #-8]
  101728:	e51b200c 	ldr	r2, [fp, #-12]
  10172c:	e5832034 	str	r2, [r3, #52]	; 0x34
}
  101730:	e28bd000 	add	sp, fp, #0
  101734:	e8bd0800 	pop	{fp}
  101738:	e12fff1e 	bx	lr

0010173c <AT91F_PMC_EnablePeriphClock>:
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
__inline void AT91F_PMC_EnablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals
{
  10173c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101740:	e28db000 	add	fp, sp, #0
  101744:	e24dd00c 	sub	sp, sp, #12
  101748:	e50b0008 	str	r0, [fp, #-8]
  10174c:	e50b100c 	str	r1, [fp, #-12]
	pPMC->PMC_PCER = periphIds;
  101750:	e51b3008 	ldr	r3, [fp, #-8]
  101754:	e51b200c 	ldr	r2, [fp, #-12]
  101758:	e5832010 	str	r2, [r3, #16]
}
  10175c:	e28bd000 	add	sp, fp, #0
  101760:	e8bd0800 	pop	{fp}
  101764:	e12fff1e 	bx	lr

00101768 <AT91F_US_Baudrate>:
//* \brief Caluculate baud_value according to the main clock and the baud rate
//*----------------------------------------------------------------------------
__inline unsigned int AT91F_US_Baudrate (
	const unsigned int main_clock, // \arg peripheral clock
	const unsigned int baud_rate)  // \arg UART baudrate
{
  101768:	e92d4800 	push	{fp, lr}
  10176c:	e28db004 	add	fp, sp, #4
  101770:	e24dd010 	sub	sp, sp, #16
  101774:	e50b0010 	str	r0, [fp, #-16]
  101778:	e50b1014 	str	r1, [fp, #-20]
	unsigned int baud_value = ((main_clock*10)/(baud_rate * 16));
  10177c:	e51b2010 	ldr	r2, [fp, #-16]
  101780:	e1a03002 	mov	r3, r2
  101784:	e1a03103 	lsl	r3, r3, #2
  101788:	e0833002 	add	r3, r3, r2
  10178c:	e1a03083 	lsl	r3, r3, #1
  101790:	e1a02003 	mov	r2, r3
  101794:	e51b3014 	ldr	r3, [fp, #-20]
  101798:	e1a03203 	lsl	r3, r3, #4
  10179c:	e1a00002 	mov	r0, r2
  1017a0:	e1a01003 	mov	r1, r3
  1017a4:	eb00017e 	bl	101da4 <__aeabi_uidiv>
  1017a8:	e1a03000 	mov	r3, r0
  1017ac:	e50b3008 	str	r3, [fp, #-8]
	if ((baud_value % 10) >= 5)
  1017b0:	e51b1008 	ldr	r1, [fp, #-8]
  1017b4:	e59f3064 	ldr	r3, [pc, #100]	; 101820 <AT91F_US_Baudrate+0xb8>
  1017b8:	e0832391 	umull	r2, r3, r1, r3
  1017bc:	e1a021a3 	lsr	r2, r3, #3
  1017c0:	e1a03002 	mov	r3, r2
  1017c4:	e1a03103 	lsl	r3, r3, #2
  1017c8:	e0833002 	add	r3, r3, r2
  1017cc:	e1a03083 	lsl	r3, r3, #1
  1017d0:	e0632001 	rsb	r2, r3, r1
  1017d4:	e3520004 	cmp	r2, #4
  1017d8:	9a000006 	bls	1017f8 <AT91F_US_Baudrate+0x90>
		baud_value = (baud_value / 10) + 1;
  1017dc:	e51b2008 	ldr	r2, [fp, #-8]
  1017e0:	e59f3038 	ldr	r3, [pc, #56]	; 101820 <AT91F_US_Baudrate+0xb8>
  1017e4:	e0831392 	umull	r1, r3, r2, r3
  1017e8:	e1a031a3 	lsr	r3, r3, #3
  1017ec:	e2833001 	add	r3, r3, #1
  1017f0:	e50b3008 	str	r3, [fp, #-8]
  1017f4:	ea000004 	b	10180c <AT91F_US_Baudrate+0xa4>
	else
		baud_value /= 10;
  1017f8:	e51b2008 	ldr	r2, [fp, #-8]
  1017fc:	e59f301c 	ldr	r3, [pc, #28]	; 101820 <AT91F_US_Baudrate+0xb8>
  101800:	e0831392 	umull	r1, r3, r2, r3
  101804:	e1a031a3 	lsr	r3, r3, #3
  101808:	e50b3008 	str	r3, [fp, #-8]
	return baud_value;
  10180c:	e51b3008 	ldr	r3, [fp, #-8]
}
  101810:	e1a00003 	mov	r0, r3
  101814:	e24bd004 	sub	sp, fp, #4
  101818:	e8bd4800 	pop	{fp, lr}
  10181c:	e12fff1e 	bx	lr
  101820:	cccccccd 	.word	0xcccccccd

00101824 <AT91F_US_SetBaudrate>:
//*----------------------------------------------------------------------------
__inline void AT91F_US_SetBaudrate (
	AT91PS_USART pUSART,    // \arg pointer to a USART controller
	unsigned int mainClock, // \arg peripheral clock
	unsigned int speed)     // \arg UART baudrate
{
  101824:	e92d4800 	push	{fp, lr}
  101828:	e28db004 	add	fp, sp, #4
  10182c:	e24dd010 	sub	sp, sp, #16
  101830:	e50b0008 	str	r0, [fp, #-8]
  101834:	e50b100c 	str	r1, [fp, #-12]
  101838:	e50b2010 	str	r2, [fp, #-16]
	//* Define the baud rate divisor register
	pUSART->US_BRGR = AT91F_US_Baudrate(mainClock, speed);
  10183c:	e51b000c 	ldr	r0, [fp, #-12]
  101840:	e51b1010 	ldr	r1, [fp, #-16]
  101844:	ebffffc7 	bl	101768 <AT91F_US_Baudrate>
  101848:	e1a02000 	mov	r2, r0
  10184c:	e51b3008 	ldr	r3, [fp, #-8]
  101850:	e5832020 	str	r2, [r3, #32]
}
  101854:	e24bd004 	sub	sp, fp, #4
  101858:	e8bd4800 	pop	{fp, lr}
  10185c:	e12fff1e 	bx	lr

00101860 <AT91F_US_SetTimeguard>:
//* \brief Set USART timeguard
//*----------------------------------------------------------------------------
__inline void AT91F_US_SetTimeguard (
	AT91PS_USART pUSART,    // \arg pointer to a USART controller
	unsigned int timeguard) // \arg timeguard value
{
  101860:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101864:	e28db000 	add	fp, sp, #0
  101868:	e24dd00c 	sub	sp, sp, #12
  10186c:	e50b0008 	str	r0, [fp, #-8]
  101870:	e50b100c 	str	r1, [fp, #-12]
	//* Write the Timeguard Register
	pUSART->US_TTGR = timeguard ;
  101874:	e51b3008 	ldr	r3, [fp, #-8]
  101878:	e51b200c 	ldr	r2, [fp, #-12]
  10187c:	e5832028 	str	r2, [r3, #40]	; 0x28
}
  101880:	e28bd000 	add	sp, fp, #0
  101884:	e8bd0800 	pop	{fp}
  101888:	e12fff1e 	bx	lr

0010188c <AT91F_US_EnableIt>:
//* \brief Enable USART IT
//*----------------------------------------------------------------------------
__inline void AT91F_US_EnableIt (
	AT91PS_USART pUSART, // \arg pointer to a USART controller
	unsigned int flag)   // \arg IT to be enabled
{
  10188c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101890:	e28db000 	add	fp, sp, #0
  101894:	e24dd00c 	sub	sp, sp, #12
  101898:	e50b0008 	str	r0, [fp, #-8]
  10189c:	e50b100c 	str	r1, [fp, #-12]
	//* Write to the IER register
	pUSART->US_IER = flag;
  1018a0:	e51b3008 	ldr	r3, [fp, #-8]
  1018a4:	e51b200c 	ldr	r2, [fp, #-12]
  1018a8:	e5832008 	str	r2, [r3, #8]
}
  1018ac:	e28bd000 	add	sp, fp, #0
  1018b0:	e8bd0800 	pop	{fp}
  1018b4:	e12fff1e 	bx	lr

001018b8 <AT91F_US_Configure>:
	AT91PS_USART pUSART,     // \arg pointer to a USART controller
	unsigned int mainClock,  // \arg peripheral clock
	unsigned int mode ,      // \arg mode Register to be programmed
	unsigned int baudRate ,  // \arg baudrate to be programmed
	unsigned int timeguard ) // \arg timeguard to be programmed
{
  1018b8:	e92d4800 	push	{fp, lr}
  1018bc:	e28db004 	add	fp, sp, #4
  1018c0:	e24dd010 	sub	sp, sp, #16
  1018c4:	e50b0008 	str	r0, [fp, #-8]
  1018c8:	e50b100c 	str	r1, [fp, #-12]
  1018cc:	e50b2010 	str	r2, [fp, #-16]
  1018d0:	e50b3014 	str	r3, [fp, #-20]
    //* Disable interrupts
    pUSART->US_IDR = (unsigned int) -1;
  1018d4:	e51b3008 	ldr	r3, [fp, #-8]
  1018d8:	e3e02000 	mvn	r2, #0
  1018dc:	e583200c 	str	r2, [r3, #12]

    //* Reset receiver and transmitter
    pUSART->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX | AT91C_US_RXDIS | AT91C_US_TXDIS ;
  1018e0:	e51b3008 	ldr	r3, [fp, #-8]
  1018e4:	e3a020ac 	mov	r2, #172	; 0xac
  1018e8:	e5832000 	str	r2, [r3]

	//* Define the baud rate divisor register
	AT91F_US_SetBaudrate(pUSART, mainClock, baudRate);
  1018ec:	e51b0008 	ldr	r0, [fp, #-8]
  1018f0:	e51b100c 	ldr	r1, [fp, #-12]
  1018f4:	e51b2014 	ldr	r2, [fp, #-20]
  1018f8:	ebffffc9 	bl	101824 <AT91F_US_SetBaudrate>

	//* Write the Timeguard Register
	AT91F_US_SetTimeguard(pUSART, timeguard);
  1018fc:	e51b0008 	ldr	r0, [fp, #-8]
  101900:	e59b1004 	ldr	r1, [fp, #4]
  101904:	ebffffd5 	bl	101860 <AT91F_US_SetTimeguard>

    //* Clear Transmit and Receive Counters
    AT91F_PDC_Open((AT91PS_PDC) &(pUSART->US_RPR));
  101908:	e51b3008 	ldr	r3, [fp, #-8]
  10190c:	e2833c01 	add	r3, r3, #256	; 0x100
  101910:	e1a00003 	mov	r0, r3
  101914:	ebffff35 	bl	1015f0 <AT91F_PDC_Open>

    //* Define the USART mode
    pUSART->US_MR = mode  ;
  101918:	e51b3008 	ldr	r3, [fp, #-8]
  10191c:	e51b2010 	ldr	r2, [fp, #-16]
  101920:	e5832004 	str	r2, [r3, #4]

}
  101924:	e24bd004 	sub	sp, fp, #4
  101928:	e8bd4800 	pop	{fp, lr}
  10192c:	e12fff1e 	bx	lr

00101930 <AT91F_US_TxReady>:
//* \fn    AT91F_US_TxReady
//* \brief Return 1 if a character can be written in US_THR
//*----------------------------------------------------------------------------
__inline unsigned int AT91F_US_TxReady (
	AT91PS_USART pUSART )     // \arg pointer to a USART controller
{
  101930:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101934:	e28db000 	add	fp, sp, #0
  101938:	e24dd00c 	sub	sp, sp, #12
  10193c:	e50b0008 	str	r0, [fp, #-8]
    return (pUSART->US_CSR & AT91C_US_TXRDY);
  101940:	e51b3008 	ldr	r3, [fp, #-8]
  101944:	e5933014 	ldr	r3, [r3, #20]
  101948:	e2033002 	and	r3, r3, #2
}
  10194c:	e1a00003 	mov	r0, r3
  101950:	e28bd000 	add	sp, fp, #0
  101954:	e8bd0800 	pop	{fp}
  101958:	e12fff1e 	bx	lr

0010195c <AT91F_US_PutChar>:
//* \brief Send a character,does not check if ready to send
//*----------------------------------------------------------------------------
__inline void AT91F_US_PutChar (
	AT91PS_USART pUSART,
	int character )
{
  10195c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  101960:	e28db000 	add	fp, sp, #0
  101964:	e24dd00c 	sub	sp, sp, #12
  101968:	e50b0008 	str	r0, [fp, #-8]
  10196c:	e50b100c 	str	r1, [fp, #-12]
    pUSART->US_THR = (character & 0x1FF);
  101970:	e51b300c 	ldr	r3, [fp, #-12]
  101974:	e1a03b83 	lsl	r3, r3, #23
  101978:	e1a03ba3 	lsr	r3, r3, #23
  10197c:	e51b2008 	ldr	r2, [fp, #-8]
  101980:	e582301c 	str	r3, [r2, #28]
}
  101984:	e28bd000 	add	sp, fp, #0
  101988:	e8bd0800 	pop	{fp}
  10198c:	e12fff1e 	bx	lr

00101990 <Trace_Toggel_LED>:
//*----------------------------------------------------------------------------
//* Function Name       : Trace_Toggel_LED
//* Object              : Toggel a LED
//*----------------------------------------------------------------------------
void Trace_Toggel_LED (unsigned int Led)
{
  101990:	e92d4800 	push	{fp, lr}
  101994:	e28db004 	add	fp, sp, #4
  101998:	e24dd008 	sub	sp, sp, #8
  10199c:	e50b0008 	str	r0, [fp, #-8]
    if ( (AT91F_PIO_GetInput(AT91C_BASE_PIOA) & Led ) == Led )
  1019a0:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  1019a4:	e1a009c0 	asr	r0, r0, #19
  1019a8:	ebffff43 	bl	1016bc <AT91F_PIO_GetInput>
  1019ac:	e1a02000 	mov	r2, r0
  1019b0:	e51b3008 	ldr	r3, [fp, #-8]
  1019b4:	e0022003 	and	r2, r2, r3
  1019b8:	e51b3008 	ldr	r3, [fp, #-8]
  1019bc:	e1520003 	cmp	r2, r3
  1019c0:	1a000004 	bne	1019d8 <Trace_Toggel_LED+0x48>
    {
        AT91F_PIO_ClearOutput( AT91C_BASE_PIOA, Led );
  1019c4:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  1019c8:	e1a009c0 	asr	r0, r0, #19
  1019cc:	e51b1008 	ldr	r1, [fp, #-8]
  1019d0:	ebffff4e 	bl	101710 <AT91F_PIO_ClearOutput>
  1019d4:	ea000003 	b	1019e8 <Trace_Toggel_LED+0x58>
    }
    else
    {
        AT91F_PIO_SetOutput( AT91C_BASE_PIOA, Led );
  1019d8:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  1019dc:	e1a009c0 	asr	r0, r0, #19
  1019e0:	e51b1008 	ldr	r1, [fp, #-8]
  1019e4:	ebffff3e 	bl	1016e4 <AT91F_PIO_SetOutput>
    }
}
  1019e8:	e24bd004 	sub	sp, fp, #4
  1019ec:	e8bd4800 	pop	{fp, lr}
  1019f0:	e12fff1e 	bx	lr

001019f4 <Usart_c_irq_handler>:
//* Function Name       : Usart_c_irq_handler
//* Object              : C handler interrupt function called by the interrupts
//*                       assembling routine
//*----------------------------------------------------------------------------
void Usart_c_irq_handler(void)
{
  1019f4:	e92d4800 	push	{fp, lr}
  1019f8:	e28db004 	add	fp, sp, #4
  1019fc:	e24dd008 	sub	sp, sp, #8
	AT91PS_USART USART_pt = COM0;
  101a00:	e59f31e4 	ldr	r3, [pc, #484]	; 101bec <Usart_c_irq_handler+0x1f8>
  101a04:	e5933000 	ldr	r3, [r3]
  101a08:	e50b3008 	str	r3, [fp, #-8]
	unsigned int status;

	//* get Usart status register and active interrupt
	status = USART_pt->US_CSR ;
  101a0c:	e51b3008 	ldr	r3, [fp, #-8]
  101a10:	e5933014 	ldr	r3, [r3, #20]
  101a14:	e50b300c 	str	r3, [fp, #-12]
        status &= USART_pt->US_IMR;
  101a18:	e51b3008 	ldr	r3, [fp, #-8]
  101a1c:	e5933010 	ldr	r3, [r3, #16]
  101a20:	e51b200c 	ldr	r2, [fp, #-12]
  101a24:	e0023003 	and	r3, r2, r3
  101a28:	e50b300c 	str	r3, [fp, #-12]

	if ( status & AT91C_US_RXBUFF){
  101a2c:	e51b300c 	ldr	r3, [fp, #-12]
  101a30:	e2033a01 	and	r3, r3, #4096	; 0x1000
  101a34:	e3530000 	cmp	r3, #0
  101a38:	0a00002a 	beq	101ae8 <Usart_c_irq_handler+0xf4>
	//* Toggel LED
 	Trace_Toggel_LED( AT91B_LED2) ;
  101a3c:	e3a00802 	mov	r0, #131072	; 0x20000
  101a40:	ebffffd2 	bl	101990 <Trace_Toggel_LED>
	//* transfert the char to DBGU
	 if ( first == 0){
  101a44:	e59f31a4 	ldr	r3, [pc, #420]	; 101bf0 <Usart_c_irq_handler+0x1fc>
  101a48:	e5933000 	ldr	r3, [r3]
  101a4c:	e3530000 	cmp	r3, #0
  101a50:	1a000012 	bne	101aa0 <Usart_c_irq_handler+0xac>
 	     COM0->US_RPR = (unsigned int) buff_rx1;
  101a54:	e59f3190 	ldr	r3, [pc, #400]	; 101bec <Usart_c_irq_handler+0x1f8>
  101a58:	e5933000 	ldr	r3, [r3]
  101a5c:	e59f2190 	ldr	r2, [pc, #400]	; 101bf4 <Usart_c_irq_handler+0x200>
  101a60:	e5832100 	str	r2, [r3, #256]	; 0x100
	     COM0->US_RCR = 100;
  101a64:	e59f3180 	ldr	r3, [pc, #384]	; 101bec <Usart_c_irq_handler+0x1f8>
  101a68:	e5933000 	ldr	r3, [r3]
  101a6c:	e3a02064 	mov	r2, #100	; 0x64
  101a70:	e5832104 	str	r2, [r3, #260]	; 0x104
 	     pCDC.Write(&pCDC, buff_rx,100);
  101a74:	e59f317c 	ldr	r3, [pc, #380]	; 101bf8 <Usart_c_irq_handler+0x204>
  101a78:	e5933010 	ldr	r3, [r3, #16]
  101a7c:	e59f0174 	ldr	r0, [pc, #372]	; 101bf8 <Usart_c_irq_handler+0x204>
  101a80:	e59f1174 	ldr	r1, [pc, #372]	; 101bfc <Usart_c_irq_handler+0x208>
  101a84:	e3a02064 	mov	r2, #100	; 0x64
  101a88:	e1a0e00f 	mov	lr, pc
  101a8c:	e12fff13 	bx	r3
 	     first =1;
  101a90:	e59f3158 	ldr	r3, [pc, #344]	; 101bf0 <Usart_c_irq_handler+0x1fc>
  101a94:	e3a02001 	mov	r2, #1
  101a98:	e5832000 	str	r2, [r3]
  101a9c:	ea000011 	b	101ae8 <Usart_c_irq_handler+0xf4>
	   }else{
	     COM0->US_RPR = (unsigned int) buff_rx;
  101aa0:	e59f3144 	ldr	r3, [pc, #324]	; 101bec <Usart_c_irq_handler+0x1f8>
  101aa4:	e5933000 	ldr	r3, [r3]
  101aa8:	e59f214c 	ldr	r2, [pc, #332]	; 101bfc <Usart_c_irq_handler+0x208>
  101aac:	e5832100 	str	r2, [r3, #256]	; 0x100
	     COM0->US_RCR = 100;
  101ab0:	e59f3134 	ldr	r3, [pc, #308]	; 101bec <Usart_c_irq_handler+0x1f8>
  101ab4:	e5933000 	ldr	r3, [r3]
  101ab8:	e3a02064 	mov	r2, #100	; 0x64
  101abc:	e5832104 	str	r2, [r3, #260]	; 0x104
	     pCDC.Write(&pCDC, buff_rx1,100);
  101ac0:	e59f3130 	ldr	r3, [pc, #304]	; 101bf8 <Usart_c_irq_handler+0x204>
  101ac4:	e5933010 	ldr	r3, [r3, #16]
  101ac8:	e59f0128 	ldr	r0, [pc, #296]	; 101bf8 <Usart_c_irq_handler+0x204>
  101acc:	e59f1120 	ldr	r1, [pc, #288]	; 101bf4 <Usart_c_irq_handler+0x200>
  101ad0:	e3a02064 	mov	r2, #100	; 0x64
  101ad4:	e1a0e00f 	mov	lr, pc
  101ad8:	e12fff13 	bx	r3
	     first=0;
  101adc:	e59f310c 	ldr	r3, [pc, #268]	; 101bf0 <Usart_c_irq_handler+0x1fc>
  101ae0:	e3a02000 	mov	r2, #0
  101ae4:	e5832000 	str	r2, [r3]
	   }
	}
//* Check error

	if ( status & AT91C_US_TIMEOUT){
  101ae8:	e51b300c 	ldr	r3, [fp, #-12]
  101aec:	e2033c01 	and	r3, r3, #256	; 0x100
  101af0:	e3530000 	cmp	r3, #0
  101af4:	0a000036 	beq	101bd4 <Usart_c_irq_handler+0x1e0>
	 Trace_Toggel_LED( AT91B_LED2) ;
  101af8:	e3a00802 	mov	r0, #131072	; 0x20000
  101afc:	ebffffa3 	bl	101990 <Trace_Toggel_LED>
	 status = 100 - COM0->US_RCR;
  101b00:	e59f30e4 	ldr	r3, [pc, #228]	; 101bec <Usart_c_irq_handler+0x1f8>
  101b04:	e5933000 	ldr	r3, [r3]
  101b08:	e5933104 	ldr	r3, [r3, #260]	; 0x104
  101b0c:	e2633064 	rsb	r3, r3, #100	; 0x64
  101b10:	e50b300c 	str	r3, [fp, #-12]
	 if  (status !=0){
  101b14:	e51b300c 	ldr	r3, [fp, #-12]
  101b18:	e3530000 	cmp	r3, #0
  101b1c:	0a00002c 	beq	101bd4 <Usart_c_irq_handler+0x1e0>
 	   if ( first == 0){
  101b20:	e59f30c8 	ldr	r3, [pc, #200]	; 101bf0 <Usart_c_irq_handler+0x1fc>
  101b24:	e5933000 	ldr	r3, [r3]
  101b28:	e3530000 	cmp	r3, #0
  101b2c:	1a000012 	bne	101b7c <Usart_c_irq_handler+0x188>
		COM0->US_RPR = (unsigned int) buff_rx1;
  101b30:	e59f30b4 	ldr	r3, [pc, #180]	; 101bec <Usart_c_irq_handler+0x1f8>
  101b34:	e5933000 	ldr	r3, [r3]
  101b38:	e59f20b4 	ldr	r2, [pc, #180]	; 101bf4 <Usart_c_irq_handler+0x200>
  101b3c:	e5832100 	str	r2, [r3, #256]	; 0x100
		COM0->US_RCR = 100;
  101b40:	e59f30a4 	ldr	r3, [pc, #164]	; 101bec <Usart_c_irq_handler+0x1f8>
  101b44:	e5933000 	ldr	r3, [r3]
  101b48:	e3a02064 	mov	r2, #100	; 0x64
  101b4c:	e5832104 	str	r2, [r3, #260]	; 0x104
 	        pCDC.Write(&pCDC, buff_rx,status);
  101b50:	e59f30a0 	ldr	r3, [pc, #160]	; 101bf8 <Usart_c_irq_handler+0x204>
  101b54:	e5933010 	ldr	r3, [r3, #16]
  101b58:	e59f0098 	ldr	r0, [pc, #152]	; 101bf8 <Usart_c_irq_handler+0x204>
  101b5c:	e59f1098 	ldr	r1, [pc, #152]	; 101bfc <Usart_c_irq_handler+0x208>
  101b60:	e51b200c 	ldr	r2, [fp, #-12]
  101b64:	e1a0e00f 	mov	lr, pc
  101b68:	e12fff13 	bx	r3
 	        first =1;
  101b6c:	e59f307c 	ldr	r3, [pc, #124]	; 101bf0 <Usart_c_irq_handler+0x1fc>
  101b70:	e3a02001 	mov	r2, #1
  101b74:	e5832000 	str	r2, [r3]
  101b78:	ea000011 	b	101bc4 <Usart_c_irq_handler+0x1d0>
	   }else{
	        COM0->US_RPR = (unsigned int) buff_rx;
  101b7c:	e59f3068 	ldr	r3, [pc, #104]	; 101bec <Usart_c_irq_handler+0x1f8>
  101b80:	e5933000 	ldr	r3, [r3]
  101b84:	e59f2070 	ldr	r2, [pc, #112]	; 101bfc <Usart_c_irq_handler+0x208>
  101b88:	e5832100 	str	r2, [r3, #256]	; 0x100
	        COM0->US_RCR = 100;
  101b8c:	e59f3058 	ldr	r3, [pc, #88]	; 101bec <Usart_c_irq_handler+0x1f8>
  101b90:	e5933000 	ldr	r3, [r3]
  101b94:	e3a02064 	mov	r2, #100	; 0x64
  101b98:	e5832104 	str	r2, [r3, #260]	; 0x104
	        pCDC.Write(&pCDC, buff_rx1,status);
  101b9c:	e59f3054 	ldr	r3, [pc, #84]	; 101bf8 <Usart_c_irq_handler+0x204>
  101ba0:	e5933010 	ldr	r3, [r3, #16]
  101ba4:	e59f004c 	ldr	r0, [pc, #76]	; 101bf8 <Usart_c_irq_handler+0x204>
  101ba8:	e59f1044 	ldr	r1, [pc, #68]	; 101bf4 <Usart_c_irq_handler+0x200>
  101bac:	e51b200c 	ldr	r2, [fp, #-12]
  101bb0:	e1a0e00f 	mov	lr, pc
  101bb4:	e12fff13 	bx	r3
	        first=0;
  101bb8:	e59f3030 	ldr	r3, [pc, #48]	; 101bf0 <Usart_c_irq_handler+0x1fc>
  101bbc:	e3a02000 	mov	r2, #0
  101bc0:	e5832000 	str	r2, [r3]
	    }
            COM0->US_CR = AT91C_US_STTTO;
  101bc4:	e59f3020 	ldr	r3, [pc, #32]	; 101bec <Usart_c_irq_handler+0x1f8>
  101bc8:	e5933000 	ldr	r3, [r3]
  101bcc:	e3a02b02 	mov	r2, #2048	; 0x800
  101bd0:	e5832000 	str	r2, [r3]
          }
	}
	//* Reset the satus bit for error
	 USART_pt->US_CR = AT91C_US_RSTSTA;
  101bd4:	e51b3008 	ldr	r3, [fp, #-8]
  101bd8:	e3a02c01 	mov	r2, #256	; 0x100
  101bdc:	e5832000 	str	r2, [r3]
}
  101be0:	e24bd004 	sub	sp, fp, #4
  101be4:	e8bd4800 	pop	{fp, lr}
  101be8:	e12fff1e 	bx	lr
  101bec:	002002b4 	.word	0x002002b4
  101bf0:	00200298 	.word	0x00200298
  101bf4:	00200234 	.word	0x00200234
  101bf8:	0020029c 	.word	0x0020029c
  101bfc:	002001d0 	.word	0x002001d0

00101c00 <AT91F_US_Put>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_US_Printk
//* \brief This function is used to send a string through the US channel
//*----------------------------------------------------------------------------
void AT91F_US_Put( char *buffer) // \arg pointer to a string ending by \0
{
  101c00:	e92d4800 	push	{fp, lr}
  101c04:	e28db004 	add	fp, sp, #4
  101c08:	e24dd008 	sub	sp, sp, #8
  101c0c:	e50b0008 	str	r0, [fp, #-8]
	while(*buffer != '\0') {
  101c10:	ea000011 	b	101c5c <AT91F_US_Put+0x5c>
		while (!AT91F_US_TxReady(COM0));
  101c14:	e1a00000 	nop			; (mov r0, r0)
  101c18:	e59f3058 	ldr	r3, [pc, #88]	; 101c78 <AT91F_US_Put+0x78>
  101c1c:	e5933000 	ldr	r3, [r3]
  101c20:	e1a00003 	mov	r0, r3
  101c24:	ebffff41 	bl	101930 <AT91F_US_TxReady>
  101c28:	e1a03000 	mov	r3, r0
  101c2c:	e3530000 	cmp	r3, #0
  101c30:	0afffff8 	beq	101c18 <AT91F_US_Put+0x18>
		AT91F_US_PutChar(COM0, *buffer++);
  101c34:	e59f303c 	ldr	r3, [pc, #60]	; 101c78 <AT91F_US_Put+0x78>
  101c38:	e5932000 	ldr	r2, [r3]
  101c3c:	e51b3008 	ldr	r3, [fp, #-8]
  101c40:	e5d33000 	ldrb	r3, [r3]
  101c44:	e51b1008 	ldr	r1, [fp, #-8]
  101c48:	e2811001 	add	r1, r1, #1
  101c4c:	e50b1008 	str	r1, [fp, #-8]
  101c50:	e1a00002 	mov	r0, r2
  101c54:	e1a01003 	mov	r1, r3
  101c58:	ebffff3f 	bl	10195c <AT91F_US_PutChar>
//* \fn    AT91F_US_Printk
//* \brief This function is used to send a string through the US channel
//*----------------------------------------------------------------------------
void AT91F_US_Put( char *buffer) // \arg pointer to a string ending by \0
{
	while(*buffer != '\0') {
  101c5c:	e51b3008 	ldr	r3, [fp, #-8]
  101c60:	e5d33000 	ldrb	r3, [r3]
  101c64:	e3530000 	cmp	r3, #0
  101c68:	1affffe9 	bne	101c14 <AT91F_US_Put+0x14>
		while (!AT91F_US_TxReady(COM0));
		AT91F_US_PutChar(COM0, *buffer++);
	}
}
  101c6c:	e24bd004 	sub	sp, fp, #4
  101c70:	e8bd4800 	pop	{fp, lr}
  101c74:	e12fff1e 	bx	lr
  101c78:	002002b4 	.word	0x002002b4

00101c7c <Usart_init>:
//* Input Parameters    : none
//* Output Parameters   : TRUE
//*----------------------------------------------------------------------------
void Usart_init ( void )
//* Begin
{
  101c7c:	e92d4800 	push	{fp, lr}
  101c80:	e28db004 	add	fp, sp, #4
  101c84:	e24dd008 	sub	sp, sp, #8
    COM0= AT91C_BASE_US0;
  101c88:	e59f2100 	ldr	r2, [pc, #256]	; 101d90 <Usart_init+0x114>
  101c8c:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  101c90:	e1a036c3 	asr	r3, r3, #13
  101c94:	e5823000 	str	r3, [r2]
    //* Define RXD and TXD as peripheral
    // Configure PIO controllers to periph mode
    AT91F_PIO_CfgPeriph(
  101c98:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  101c9c:	e1a009c0 	asr	r0, r0, #19
  101ca0:	e3a01003 	mov	r1, #3
  101ca4:	e3a02000 	mov	r2, #0
  101ca8:	ebfffe6f 	bl	10166c <AT91F_PIO_CfgPeriph>
	 ((unsigned int) AT91C_PA0_RXD0    ) |
	 ((unsigned int) AT91C_PA1_TXD0    ) , // Peripheral A
	 0 ); // Peripheral B

    //* First, enable the clock of the PIOB
    AT91F_PMC_EnablePeriphClock ( AT91C_BASE_PMC, 1 << AT91C_ID_US0 ) ;
  101cac:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  101cb0:	e1a00ac0 	asr	r0, r0, #21
  101cb4:	e3a01040 	mov	r1, #64	; 0x40
  101cb8:	ebfffe9f 	bl	10173c <AT91F_PMC_EnablePeriphClock>

    //* Usart Configure
    AT91F_US_Configure (COM0, AT91B_MCK,AT91C_US_ASYNC_MODE,USART_BAUD_RATE , 0);
  101cbc:	e59f30cc 	ldr	r3, [pc, #204]	; 101d90 <Usart_init+0x114>
  101cc0:	e5933000 	ldr	r3, [r3]
  101cc4:	e3a02000 	mov	r2, #0
  101cc8:	e58d2000 	str	r2, [sp]
  101ccc:	e1a00003 	mov	r0, r3
  101cd0:	e59f10bc 	ldr	r1, [pc, #188]	; 101d94 <Usart_init+0x118>
  101cd4:	e3a02d23 	mov	r2, #2240	; 0x8c0
  101cd8:	e3a03907 	mov	r3, #114688	; 0x1c000
  101cdc:	e2833c02 	add	r3, r3, #512	; 0x200
  101ce0:	ebfffef4 	bl	1018b8 <AT91F_US_Configure>

    //* Enable usart
    COM0->US_CR = AT91C_US_RXEN | AT91C_US_TXEN;
  101ce4:	e59f30a4 	ldr	r3, [pc, #164]	; 101d90 <Usart_init+0x114>
  101ce8:	e5933000 	ldr	r3, [r3]
  101cec:	e3a02050 	mov	r2, #80	; 0x50
  101cf0:	e5832000 	str	r2, [r3]

    //* open Usart interrupt
    AT91F_AIC_ConfigureIt (AT91C_BASE_AIC, AT91C_ID_US0, USART_INTERRUPT_LEVEL,
  101cf4:	e59f309c 	ldr	r3, [pc, #156]	; 101d98 <Usart_init+0x11c>
  101cf8:	e58d3000 	str	r3, [sp]
  101cfc:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  101d00:	e1a009c0 	asr	r0, r0, #19
  101d04:	e3a01006 	mov	r1, #6
  101d08:	e3a02001 	mov	r2, #1
  101d0c:	e3a03000 	mov	r3, #0
  101d10:	ebfffd9e 	bl	101390 <AT91F_AIC_ConfigureIt>
                           AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL, Usart_c_irq_handler);
    AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_US0);
  101d14:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  101d18:	e1a009c0 	asr	r0, r0, #19
  101d1c:	e3a01006 	mov	r1, #6
  101d20:	ebfffdc0 	bl	101428 <AT91F_AIC_EnableIt>
    // Set the PDC
    AT91F_PDC_Open (AT91C_BASE_PDC_US0);
  101d24:	e3a004ff 	mov	r0, #-16777216	; 0xff000000
  101d28:	e280073f 	add	r0, r0, #16515072	; 0xfc0000
  101d2c:	e2800c01 	add	r0, r0, #256	; 0x100
  101d30:	ebfffe2e 	bl	1015f0 <AT91F_PDC_Open>
    COM0->US_RPR = (unsigned int) buff_rx;
  101d34:	e59f3054 	ldr	r3, [pc, #84]	; 101d90 <Usart_init+0x114>
  101d38:	e5933000 	ldr	r3, [r3]
  101d3c:	e59f2058 	ldr	r2, [pc, #88]	; 101d9c <Usart_init+0x120>
  101d40:	e5832100 	str	r2, [r3, #256]	; 0x100
    COM0->US_RCR = 100;
  101d44:	e59f3044 	ldr	r3, [pc, #68]	; 101d90 <Usart_init+0x114>
  101d48:	e5933000 	ldr	r3, [r3]
  101d4c:	e3a02064 	mov	r2, #100	; 0x64
  101d50:	e5832104 	str	r2, [r3, #260]	; 0x104
    first = 0;
  101d54:	e59f3044 	ldr	r3, [pc, #68]	; 101da0 <Usart_init+0x124>
  101d58:	e3a02000 	mov	r2, #0
  101d5c:	e5832000 	str	r2, [r3]
    COM0->US_RTOR = 10;
  101d60:	e59f3028 	ldr	r3, [pc, #40]	; 101d90 <Usart_init+0x114>
  101d64:	e5933000 	ldr	r3, [r3]
  101d68:	e3a0200a 	mov	r2, #10
  101d6c:	e5832024 	str	r2, [r3, #36]	; 0x24
    //* Enable USART IT error and AT91C_US_ENDRX
     AT91F_US_EnableIt(COM0,AT91C_US_RXBUFF | AT91C_US_TIMEOUT );
  101d70:	e59f3018 	ldr	r3, [pc, #24]	; 101d90 <Usart_init+0x114>
  101d74:	e5933000 	ldr	r3, [r3]
  101d78:	e1a00003 	mov	r0, r3
  101d7c:	e3a01c11 	mov	r1, #4352	; 0x1100
  101d80:	ebfffec1 	bl	10188c <AT91F_US_EnableIt>
//* End
}
  101d84:	e24bd004 	sub	sp, fp, #4
  101d88:	e8bd4800 	pop	{fp, lr}
  101d8c:	e12fff1e 	bx	lr
  101d90:	002002b4 	.word	0x002002b4
  101d94:	02dd4249 	.word	0x02dd4249
  101d98:	001019f4 	.word	0x001019f4
  101d9c:	002001d0 	.word	0x002001d0
  101da0:	00200298 	.word	0x00200298

00101da4 <__aeabi_uidiv>:
  101da4:	e2512001 	subs	r2, r1, #1
  101da8:	012fff1e 	bxeq	lr
  101dac:	3a000036 	bcc	101e8c <__aeabi_uidiv+0xe8>
  101db0:	e1500001 	cmp	r0, r1
  101db4:	9a000022 	bls	101e44 <__aeabi_uidiv+0xa0>
  101db8:	e1110002 	tst	r1, r2
  101dbc:	0a000023 	beq	101e50 <__aeabi_uidiv+0xac>
  101dc0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
  101dc4:	01a01181 	lsleq	r1, r1, #3
  101dc8:	03a03008 	moveq	r3, #8
  101dcc:	13a03001 	movne	r3, #1
  101dd0:	e3510201 	cmp	r1, #268435456	; 0x10000000
  101dd4:	31510000 	cmpcc	r1, r0
  101dd8:	31a01201 	lslcc	r1, r1, #4
  101ddc:	31a03203 	lslcc	r3, r3, #4
  101de0:	3afffffa 	bcc	101dd0 <__aeabi_uidiv+0x2c>
  101de4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
  101de8:	31510000 	cmpcc	r1, r0
  101dec:	31a01081 	lslcc	r1, r1, #1
  101df0:	31a03083 	lslcc	r3, r3, #1
  101df4:	3afffffa 	bcc	101de4 <__aeabi_uidiv+0x40>
  101df8:	e3a02000 	mov	r2, #0
  101dfc:	e1500001 	cmp	r0, r1
  101e00:	20400001 	subcs	r0, r0, r1
  101e04:	21822003 	orrcs	r2, r2, r3
  101e08:	e15000a1 	cmp	r0, r1, lsr #1
  101e0c:	204000a1 	subcs	r0, r0, r1, lsr #1
  101e10:	218220a3 	orrcs	r2, r2, r3, lsr #1
  101e14:	e1500121 	cmp	r0, r1, lsr #2
  101e18:	20400121 	subcs	r0, r0, r1, lsr #2
  101e1c:	21822123 	orrcs	r2, r2, r3, lsr #2
  101e20:	e15001a1 	cmp	r0, r1, lsr #3
  101e24:	204001a1 	subcs	r0, r0, r1, lsr #3
  101e28:	218221a3 	orrcs	r2, r2, r3, lsr #3
  101e2c:	e3500000 	cmp	r0, #0
  101e30:	11b03223 	lsrsne	r3, r3, #4
  101e34:	11a01221 	lsrne	r1, r1, #4
  101e38:	1affffef 	bne	101dfc <__aeabi_uidiv+0x58>
  101e3c:	e1a00002 	mov	r0, r2
  101e40:	e12fff1e 	bx	lr
  101e44:	03a00001 	moveq	r0, #1
  101e48:	13a00000 	movne	r0, #0
  101e4c:	e12fff1e 	bx	lr
  101e50:	e3510801 	cmp	r1, #65536	; 0x10000
  101e54:	21a01821 	lsrcs	r1, r1, #16
  101e58:	23a02010 	movcs	r2, #16
  101e5c:	33a02000 	movcc	r2, #0
  101e60:	e3510c01 	cmp	r1, #256	; 0x100
  101e64:	21a01421 	lsrcs	r1, r1, #8
  101e68:	22822008 	addcs	r2, r2, #8
  101e6c:	e3510010 	cmp	r1, #16
  101e70:	21a01221 	lsrcs	r1, r1, #4
  101e74:	22822004 	addcs	r2, r2, #4
  101e78:	e3510004 	cmp	r1, #4
  101e7c:	82822003 	addhi	r2, r2, #3
  101e80:	908220a1 	addls	r2, r2, r1, lsr #1
  101e84:	e1a00230 	lsr	r0, r0, r2
  101e88:	e12fff1e 	bx	lr
  101e8c:	e3500000 	cmp	r0, #0
  101e90:	13e00000 	mvnne	r0, #0
  101e94:	ea000007 	b	101eb8 <__aeabi_idiv0>

00101e98 <__aeabi_uidivmod>:
  101e98:	e3510000 	cmp	r1, #0
  101e9c:	0afffffa 	beq	101e8c <__aeabi_uidiv+0xe8>
  101ea0:	e92d4003 	push	{r0, r1, lr}
  101ea4:	ebffffbe 	bl	101da4 <__aeabi_uidiv>
  101ea8:	e8bd4006 	pop	{r1, r2, lr}
  101eac:	e0030092 	mul	r3, r2, r0
  101eb0:	e0411003 	sub	r1, r1, r3
  101eb4:	e12fff1e 	bx	lr

00101eb8 <__aeabi_idiv0>:
  101eb8:	e12fff1e 	bx	lr

00101ebc <devDescriptor>:
  101ebc:	01100112 08000002 612503eb 00000110     ..........%a....
  101ecc:	00000100                                ....

00101ed0 <cfgDescriptor>:
  101ed0:	00430209 c0000102 00040900 02020100     ..C.............
  101ee0:	24050000 04011000 05000224 01000624     ...$....$...$...
  101ef0:	00012405 83050701 ff000803 00010409     .$..............
  101f00:	00000a02 01050700 00004002 02820507     .........@......
  101f10:	00000040                                @...

Disassembly of section .data:

00200000 <_data>:
.else
.print "Vectors in section .vectorg -> .text"
.section .vectorg, "ax"
.endif

			LDR     PC,Reset_Addr     	/* 0x00 Reset handler */    
  200000:	e59ff03c 	ldr	pc, [pc, #60]	; 200044 <Reset_Addr>
			LDR     PC,Undef_Addr		/* 0x04 Undefined Instruction */
  200004:	e59ff03c 	ldr	pc, [pc, #60]	; 200048 <Undef_Addr>
			LDR     PC,SWI_Addr			/* 0x08 Software Interrupt */
  200008:	e59ff03c 	ldr	pc, [pc, #60]	; 20004c <SWI_Addr>
			LDR     PC,PAbt_Addr		/* 0x0C Prefetch Abort */
  20000c:	e59ff03c 	ldr	pc, [pc, #60]	; 200050 <PAbt_Addr>
			LDR     PC,DAbt_Addr		/* 0x10 Data Abort */
  200010:	e59ff03c 	ldr	pc, [pc, #60]	; 200054 <DAbt_Addr>
			NOP							/* 0x14 reserved  */
  200014:	e1a00000 	nop			; (mov r0, r0)
			LDR     PC,IRQ_Addr			/* 0x18 IRQ	 */
  200018:	e59ff038 	ldr	pc, [pc, #56]	; 200058 <IRQ_Addr>

0020001c <FIQ_Handler_Entry>:

/*- Switch in SVC/User Mode to allow User Stack access for C code 	*/
/* because the FIQ is not yet acknowledged*/

/*- Save and r0 in FIQ_Register */
            mov         r9,r0
  20001c:	e1a09000 	mov	r9, r0
            ldr         r0 , [r8, #AIC_FVR]
  200020:	e5980104 	ldr	r0, [r8, #260]	; 0x104
            msr         CPSR_c,#I_BIT | F_BIT | ARM_MODE_SVC
  200024:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

/*- Save scratch/used registers and LR in User Stack */
            stmfd       sp!, { r1-r3, r12, lr}
  200028:	e92d500e 	push	{r1, r2, r3, ip, lr}

/*- Branch to the routine pointed by the AIC_FVR */
            mov         r14, pc
  20002c:	e1a0e00f 	mov	lr, pc
            bx          r0
  200030:	e12fff10 	bx	r0

/*- Restore scratch/used registers and LR from User Stack */
            ldmia       sp!, { r1-r3, r12, lr}
  200034:	e8bd500e 	pop	{r1, r2, r3, ip, lr}

/*- Leave Interrupts disabled and switch back in FIQ mode */
            msr         CPSR_c, #I_BIT | F_BIT | ARM_MODE_FIQ
  200038:	e321f0d1 	msr	CPSR_c, #209	; 0xd1

/*- Restore the R0 ARM_MODE_SVC register */
            mov         r0,r9
  20003c:	e1a00009 	mov	r0, r9

/*- Restore the Program Counter using the LR_fiq directly in the PC */
            subs        pc,lr,#4
  200040:	e25ef004 	subs	pc, lr, #4

00200044 <Reset_Addr>:
  200044:	00100028 	.word	0x00100028

00200048 <Undef_Addr>:
  200048:	0020005c 	.word	0x0020005c

0020004c <SWI_Addr>:
  20004c:	002000c8 	.word	0x002000c8

00200050 <PAbt_Addr>:
  200050:	00200060 	.word	0x00200060

00200054 <DAbt_Addr>:
  200054:	00200064 	.word	0x00200064

00200058 <IRQ_Addr>:
  200058:	00200068 	.word	0x00200068

0020005c <Undef_Handler>:
SWI_Addr:         .word     SoftwareInterruptASM      /* in swi_handler.S */
PAbt_Addr:        .word     PAbt_Handler
DAbt_Addr:        .word     DAbt_Handler
IRQ_Addr:         .word     IRQ_Handler_Entry
  
Undef_Handler:  B       Undef_Handler
  20005c:	eafffffe 	b	20005c <Undef_Handler>

00200060 <PAbt_Handler>:
/* SWI_Handler:    B       SWI_Handler */
PAbt_Handler:   B       PAbt_Handler
  200060:	eafffffe 	b	200060 <PAbt_Handler>

00200064 <DAbt_Handler>:
DAbt_Handler:   B       DAbt_Handler
  200064:	eafffffe 	b	200064 <DAbt_Handler>

00200068 <IRQ_Handler_Entry>:

IRQ_Handler_Entry:

/*- Manage Exception Entry  */
/*- Adjust and save LR_irq in IRQ stack  */
            sub         lr, lr, #4
  200068:	e24ee004 	sub	lr, lr, #4
            stmfd       sp!, {lr}
  20006c:	e92d4000 	push	{lr}

/*- Save SPSR need to be saved for nested interrupt */
            mrs         r14, SPSR
  200070:	e14fe000 	mrs	lr, SPSR
            stmfd       sp!, {r14}
  200074:	e92d4000 	push	{lr}

/*- Save and r0 in IRQ stack  */
            stmfd       sp!, {r0}
  200078:	e92d0001 	push	{r0}

/*- Write in the IVR to support Protect Mode  */
/*- No effect in Normal Mode  */
/*- De-assert the NIRQ and clear the source in Protect Mode */
            ldr         r14, =AT91C_BASE_AIC
  20007c:	e59fe040 	ldr	lr, [pc, #64]	; 2000c4 <AT91F_Spurious_handler+0x4>
            ldr         r0 , [r14, #AIC_IVR]
  200080:	e59e0100 	ldr	r0, [lr, #256]	; 0x100
            str         r14, [r14, #AIC_IVR]
  200084:	e58ee100 	str	lr, [lr, #256]	; 0x100

/*- Enable Interrupt and Switch in Supervisor Mode */
            msr         CPSR_c, #ARM_MODE_SVC
  200088:	e321f013 	msr	CPSR_c, #19

/*- Save scratch/used registers and LR in User Stack */
            stmfd       sp!, { r1-r3, r12, r14}
  20008c:	e92d500e 	push	{r1, r2, r3, ip, lr}

/*- Branch to the routine pointed by the AIC_IVR  */
            mov         r14, pc
  200090:	e1a0e00f 	mov	lr, pc
            bx          r0
  200094:	e12fff10 	bx	r0
/*- Restore scratch/used registers and LR from User Stack*/
            ldmia       sp!, { r1-r3, r12, r14}
  200098:	e8bd500e 	pop	{r1, r2, r3, ip, lr}

/*- Disable Interrupt and switch back in IRQ mode */
            msr         CPSR_c, #I_BIT | ARM_MODE_IRQ
  20009c:	e321f092 	msr	CPSR_c, #146	; 0x92

/*- Mark the End of Interrupt on the AIC */
            ldr         r14, =AT91C_BASE_AIC
  2000a0:	e59fe01c 	ldr	lr, [pc, #28]	; 2000c4 <AT91F_Spurious_handler+0x4>
            str         r14, [r14, #AIC_EOICR]
  2000a4:	e58ee130 	str	lr, [lr, #304]	; 0x130

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r0}
  2000a8:	e8bd0001 	pop	{r0}

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r14}
  2000ac:	e8bd4000 	pop	{lr}
            msr         SPSR_cxsf, r14
  2000b0:	e16ff00e 	msr	SPSR_fsxc, lr

/*- Restore adjusted  LR_irq from IRQ stack directly in the PC */
            ldmia       sp!, {pc}^
  2000b4:	e8fd8000 	ldm	sp!, {pc}^

002000b8 <AT91F_Default_FIQ_handler>:
//* This module is only linked if needed for closing files.
//*---------------------------------------------------------------*/
        .global AT91F_Default_FIQ_handler
        .func   AT91F_Default_FIQ_handler
AT91F_Default_FIQ_handler:
            b     AT91F_Default_FIQ_handler
  2000b8:	eafffffe 	b	2000b8 <AT91F_Default_FIQ_handler>

002000bc <AT91F_Default_IRQ_handler>:
        .endfunc

        .global AT91F_Default_IRQ_handler
        .func   AT91F_Default_IRQ_handler
AT91F_Default_IRQ_handler:
            b     AT91F_Default_IRQ_handler
  2000bc:	eafffffe 	b	2000bc <AT91F_Default_IRQ_handler>

002000c0 <AT91F_Spurious_handler>:
        .endfunc

        .global AT91F_Spurious_handler
        .func   AT91F_Spurious_handler
AT91F_Spurious_handler:
            b     AT91F_Spurious_handler
  2000c0:	eafffffe 	b	2000c0 <AT91F_Spurious_handler>
  2000c4:	fffff000 	.word	0xfffff000

002000c8 <SoftwareInterruptASM>:

  
.global SoftwareInterruptASM
.func   SoftwareInterruptASM
SoftwareInterruptASM:
	STMFD   sp!, {r4, lr}      /* store regs. */
  2000c8:	e92d4010 	push	{r4, lr}
	MRS     r4, spsr
  2000cc:	e14f4000 	mrs	r4, SPSR
	TST     r4, #T_Bit             /* test for thumb */
  2000d0:	e3140020 	tst	r4, #32
	LDRNEH  r4, [lr, #-2]          /* NE->thumb - get swi instruction code */
  2000d4:	115e40b2 	ldrhne	r4, [lr, #-2]
	BICNE   r4, r4, #0xff00        /* NE->thumb - clear top 8 bits leaving swi "comment field"=number */
  2000d8:	13c44cff 	bicne	r4, r4, #65280	; 0xff00
	LDREQ   r4, [lr, #-4]          /* EQ->arm - get swi instruction code */
  2000dc:	051e4004 	ldreq	r4, [lr, #-4]
	BICEQ   r4, r4, #0xff000000    /* EQ->arm - clear top 8 bits leaving swi "comment field"=number */
  2000e0:	03c444ff 	biceq	r4, r4, #-16777216	; 0xff000000
	CMP     r4, #MAX_SWI           /* range-check */
  2000e4:	e3540006 	cmp	r4, #6
	LDRLS   pc, [pc, r4, LSL #2]   /* jump to routine if <= MAX (LS) */
  2000e8:	979ff104 	ldrls	pc, [pc, r4, lsl #2]

/* if none from the predefined SWIs match call the users-handler */
	B       UserSWIHandler
  2000ec:	ea000028 	b	200194 <UserSWIHandler>

002000f0 <SwiTableStart>:
  2000f0:	0020010c 	.word	0x0020010c
  2000f4:	0020011c 	.word	0x0020011c
  2000f8:	0020012c 	.word	0x0020012c
  2000fc:	00200140 	.word	0x00200140
  200100:	00200154 	.word	0x00200154
  200104:	0020015c 	.word	0x0020015c
  200108:	00200178 	.word	0x00200178

0020010c <IRQDisable>:
	.word FIQRestore	// 6
SwiTableEnd:
	.set MAX_SWI, ((SwiTableEnd-SwiTableStart)/4)-1

IRQDisable:
	MRS     r0, SPSR                        /* Get SPSR = return value */
  20010c:	e14f0000 	mrs	r0, SPSR
	ORR     r4, r0, #I_Bit                  /* I_Bit set */
  200110:	e3804080 	orr	r4, r0, #128	; 0x80
	MSR     SPSR_c, r4                      /* Set SPSR */
  200114:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
  200118:	ea000028 	b	2001c0 <EndofSWI>

0020011c <IRQEnable>:
   	
IRQEnable:
	MRS     r0, SPSR                        /* Get SPSR = return value */
  20011c:	e14f0000 	mrs	r0, SPSR
	BIC     r4, r0, #I_Bit                  /* I_Bit clear */
  200120:	e3c04080 	bic	r4, r0, #128	; 0x80
	MSR     SPSR_c, r4                      /* Set SPSR */
  200124:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI                       
  200128:	ea000024 	b	2001c0 <EndofSWI>

0020012c <FIQDisable>:
 
FIQDisable:
	MRS     r0, SPSR
  20012c:	e14f0000 	mrs	r0, SPSR
	ORR     r4, r0, #F_Bit
  200130:	e3804040 	orr	r4, r0, #64	; 0x40
	AND     r0, r0, #F_Bit
  200134:	e2000040 	and	r0, r0, #64	; 0x40
	MSR     SPSR_c, r4
  200138:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
  20013c:	ea00001f 	b	2001c0 <EndofSWI>

00200140 <FIQEnable>:

FIQEnable:
	MRS     r0, SPSR
  200140:	e14f0000 	mrs	r0, SPSR
	BIC     r4, r0, #F_Bit
  200144:	e3c04040 	bic	r4, r0, #64	; 0x40
	AND     r0, r0, #F_Bit
  200148:	e2000040 	and	r0, r0, #64	; 0x40
	MSR     SPSR_c, r4
  20014c:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
  200150:	ea00001a 	b	2001c0 <EndofSWI>

00200154 <CPSRget>:

CPSRget:
	// LDR r0, =0xdeadbeef
	MRS     r0, SPSR                        /* Get SPSR */
  200154:	e14f0000 	mrs	r0, SPSR
	B       EndofSWI                       
  200158:	ea000018 	b	2001c0 <EndofSWI>

0020015c <IRQRestore>:

IRQRestore:
	MRS     r4, SPSR                        /* Get SPSR */
  20015c:	e14f4000 	mrs	r4, SPSR
	AND     r0, r0, #I_Bit
  200160:	e2000080 	and	r0, r0, #128	; 0x80
	TST     r0, #I_Bit             /* Test input for I_Bit */
  200164:	e3100080 	tst	r0, #128	; 0x80
	BICEQ   r4, r4, #I_Bit
  200168:	03c44080 	biceq	r4, r4, #128	; 0x80
	ORRNE   r4, r4, #I_Bit
  20016c:	13844080 	orrne	r4, r4, #128	; 0x80
	MSR     SPSR_c, r4
  200170:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
  200174:	ea000011 	b	2001c0 <EndofSWI>

00200178 <FIQRestore>:

FIQRestore:
	MRS     r4, SPSR                        /* Get SPSR */
  200178:	e14f4000 	mrs	r4, SPSR
	AND     r0, r0, #F_Bit
  20017c:	e2000040 	and	r0, r0, #64	; 0x40
	TST     r0, #F_Bit             /* Test input for F_Bit */
  200180:	e3100040 	tst	r0, #64	; 0x40
	BICEQ   r4, r4, #F_Bit
  200184:	03c44040 	biceq	r4, r4, #64	; 0x40
	ORRNE   r4, r4, #F_Bit
  200188:	13844040 	orrne	r4, r4, #64	; 0x40
	MSR     SPSR_c, r4
  20018c:	e161f004 	msr	SPSR_c, r4
	B       EndofSWI
  200190:	ea00000a 	b	2001c0 <EndofSWI>

00200194 <UserSWIHandler>:

UserSWIHandler:
	stmfd	sp!,{r1-r12,lr}
  200194:	e92d5ffe 	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	mrs	r12, spsr
  200198:	e14fc000 	mrs	ip, SPSR
	stmfd	sp!, {r12}
  20019c:	e92d1000 	push	{ip}
	ldr     r12, =SWI_Handler_User
  2001a0:	e59fc01c 	ldr	ip, [pc, #28]	; 2001c4 <EndofSWI+0x4>
	mov     r3, r4 /* pass SWI-Number as Param */
  2001a4:	e1a03004 	mov	r3, r4
	mov     lr, pc
  2001a8:	e1a0e00f 	mov	lr, pc
	bx      r12    /* call c-function */
  2001ac:	e12fff1c 	bx	ip
	ldmfd	sp!, {r12}
  2001b0:	e8bd1000 	pop	{ip}
	msr	spsr_cxsf, r12
  2001b4:	e16ff00c 	msr	SPSR_fsxc, ip
	ldmfd	sp!, {r1-r12,pc}^  /* return-value in r0 */
  2001b8:	e8fd9ffe 	ldm	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^
	b	EndofSWI
  2001bc:	eaffffff 	b	2001c0 <EndofSWI>

002001c0 <EndofSWI>:

EndofSWI:
	LDMFD   sp!, {r4,pc}^
  2001c0:	e8fd8010 	ldm	sp!, {r4, pc}^
  2001c4:	001002b0 	.word	0x001002b0

002001c8 <line>:
  2001c8:	0001c200 00080000                       ........

Creating Symbol Table: main.sym
arm-none-eabi-nm -n main.elf
00000000 a MC_RCR
00000000 a RAM_MODE
00000000 a SWI_IRQ_DIS
00000001 a REMAP
00000001 a SWI_IRQ_EN
00000001 a VECTREMAPPED
00000001 a VECTREMAPPED
00000002 a SWI_FIQ_DIS
00000003 a SWI_FIQ_EN
00000004 a SWI_GET_CPSR
00000005 a SWI_IRQ_REST
00000006 a MAX_SWI
00000006 a SWI_FIQ_REST
00000011 a ARM_MODE_FIQ
00000012 a ARM_MODE_IRQ
00000013 a ARM_MODE_SVC
00000020 a T_Bit
00000040 a F_BIT
00000040 a F_Bit
00000060 a IRQ_STACK_SIZE
00000080 a I_BIT
00000080 a I_Bit
00000100 a AIC_IVR
00000104 a AIC_FVR
00000130 a AIC_EOICR
00100000 T _startup
00100000 t reset
00100020 t Reset_Addr_F
00100024 t .RAM_TOP
00100028 t InitReset
00100060 t already_remapped
0010009c t LoopRel
001000b8 t LoopZI
001000cc t ctor_loop
001000ec t ctor_end
001000f8 T exit
00100130 T AT91F_LowLevelInit
001002b0 T SWI_Handler_User
001002e8 t AT91F_PIO_CfgOutput
00100320 t AT91F_PIO_SetOutput
0010034c t AT91F_PIO_ClearOutput
00100378 t AT91F_PMC_EnablePeriphClock
001003a4 T AT91F_USB_Open
00100428 T main
00100538 T AT91F_CDC_Open
001005c0 t AT91F_UDP_IsConfigured
00100678 t AT91F_UDP_Read
00100800 t AT91F_UDP_Write
00100a18 t AT91F_USB_SendData
00100ba4 T AT91F_USB_SendZlp
00100c1c T AT91F_USB_SendStall
00100c90 t AT91F_CDC_Enumerate
00101390 t AT91F_AIC_ConfigureIt
00101428 t AT91F_AIC_EnableIt
00101460 t AT91F_PDC_SetNextRx
0010149c t AT91F_PDC_SetNextTx
001014d8 t AT91F_PDC_SetRx
00101514 t AT91F_PDC_SetTx
00101550 t AT91F_PDC_EnableTx
00101578 t AT91F_PDC_EnableRx
001015a0 t AT91F_PDC_DisableTx
001015c8 t AT91F_PDC_DisableRx
001015f0 t AT91F_PDC_Open
0010166c t AT91F_PIO_CfgPeriph
001016bc t AT91F_PIO_GetInput
001016e4 t AT91F_PIO_SetOutput
00101710 t AT91F_PIO_ClearOutput
0010173c t AT91F_PMC_EnablePeriphClock
00101768 t AT91F_US_Baudrate
00101824 t AT91F_US_SetBaudrate
00101860 t AT91F_US_SetTimeguard
0010188c t AT91F_US_EnableIt
001018b8 t AT91F_US_Configure
00101930 t AT91F_US_TxReady
0010195c t AT91F_US_PutChar
00101990 T Trace_Toggel_LED
001019f4 T Usart_c_irq_handler
00101c00 T AT91F_US_Put
00101c7c T Usart_init
00101da4 t .udivsi3_skip_div0_test
00101da4 T __aeabi_uidiv
00101da4 T __udivsi3
00101e98 T __aeabi_uidivmod
00101eb8 W __aeabi_idiv0
00101eb8 W __aeabi_ldiv0
00101ebc T devDescriptor
00101ed0 T cfgDescriptor
00101f14 D __ctors_end__
00101f14 D __ctors_start__
00101f14 A _etext
00200000 A __FIRST_IN_RAM
00200000 D _data
0020001c d FIQ_Handler_Entry
0020001c d fiqvec
00200044 d Reset_Addr
00200048 d Undef_Addr
0020004c d SWI_Addr
00200050 d PAbt_Addr
00200054 d DAbt_Addr
00200058 d IRQ_Addr
0020005c d Undef_Handler
00200060 d PAbt_Handler
00200064 d DAbt_Handler
00200068 D IRQ_Handler_Entry
002000b8 D AT91F_Default_FIQ_handler
002000bc D AT91F_Default_IRQ_handler
002000c0 D AT91F_Spurious_handler
002000c8 D SoftwareInterruptASM
002000f0 d SwiTableStart
0020010c d IRQDisable
0020010c d SwiTableEnd
0020011c d IRQEnable
0020012c d FIQDisable
00200140 d FIQEnable
00200154 d CPSRget
0020015c d IRQRestore
00200178 d FIQRestore
00200194 d UserSWIHandler
002001c0 d EndofSWI
002001c8 D line
002001d0 B __bss_start
002001d0 B __bss_start__
002001d0 A _edata
002001d0 b buff_rx
00200234 b buff_rx1
00200298 B first
0020029c B pCDC
002002b4 B COM0
002002b8 A __bss_end__
002002b8 A _end
00210000 A __TOP_STACK
fffff000 a AT91C_BASE_AIC
ffffff00 a MC_BASE
copying...
`cp main.elf main.out`

Size after:
d:\olimexods82\yagarto\bin\arm-none-eabi-size.exe: 'a.out': No such file

Errors: none
-------- end --------

